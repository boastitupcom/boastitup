Tech Story Campaign Creation - Step 1



By GenAIWorkggn

10 min

See views

Add a reaction
Tech Story: Campaign Setup - Basic Information Step
📌 Feature Name
Campaign Setup - Basic Information Step - First step of 4-step campaign creation wizard with AI assistance and dynamic type selection

🎯 Introduction
The initial step of campaign creation where users enter basic campaign details including name (with AI suggestions), campaign type selection from database enums, description with AI writing assistance, date selection with optimization tips, budget slider, and real-time performance predictions. The interface combines static UI elements with dynamic data from multiple sources including form state, database queries, and external AI services.

Business outcome: Streamlines the most critical campaign setup decisions in the first step, reducing abandonment by 40% through AI suggestions, database-driven type selection, and real-time validation feedback for SMEs and marketing teams.

❗ Problem Statement
Users abandon campaign creation at the first step due to decision paralysis on campaign naming (blank field syndrome), unclear campaign type differences, and complex form layouts. 60% of users exit without completing basic information due to overwhelming choices, lack of guidance, and static hardcoded options that don't reflect current business needs. Teams waste 45 minutes per campaign on initial setup decisions that could be AI-assisted.

✅ Solution Overview
High-level architectural approach: Next.js 15 + Supabase + shadcn/ui + React Query + AI prediction services

Key principles:

AI-powered name suggestions and writing assistance

Database-driven campaign types (no hardcoded enums)

Real-time form validation with live predictions

Progressive disclosure with contextual tips

Hybrid static/dynamic UI for optimal performance

🛠️ Technical Architecture
Data Layer
Primary Tables:

campaigns - Will store completed campaign data after all 4 steps

brands - For brand association and tenant scoping

user_tenant_roles - User permission and tenant access

Database enum: campaign_type_enum - Dynamic campaign type values

Database Functions:

get_enum_values('campaign_type_enum') - Fetch campaign types dynamically

calculate_campaign_predictions() - AI-powered performance predictions

get_competitor_averages() - Industry benchmark data

Key Relationships:

sql



campaigns.brand_id → brands.id
campaigns.tenant_id → tenants.id
user_tenant_roles.tenant_id → tenants.id
API Layer Architecture
Service Classes:

typescript



export const CampaignSetupService = {
  // DYNAMIC - External AI service
  generateNameSuggestions: async (brandId: string, industry?: string) => {
    const { data, error } = await fetch('/api/ai/campaign-names', {
      method: 'POST',
      body: JSON.stringify({ brandId, industry })
    });
    if (error) throw error;
    return data; // ["Interactive Stories Boost", "Engagement Master 2025"]
  },
  // DYNAMIC - Database RPC call
  getCampaignTypes: async () => {
    const { data, error } = await supabase.rpc('get_enum_values', { 
      enum_name: 'campaign_type_enum' 
    });
    if (error) throw error;
    return data; // ["engagement", "awareness", "conversion"]
  },
  // DYNAMIC - AI prediction service
  calculatePredictions: async (campaignData: PredictionInput) => {
    const { data, error } = await supabase.rpc('calculate_campaign_predictions', {
      p_campaign_type: campaignData.type,
      p_budget: campaignData.budget,
      p_brand_id: campaignData.brandId
    });
    if (error) throw error;
    return data; // { reachMin: 25000, reachMax: 40000, confidence: 78 }
  },
  // DYNAMIC - Database query
  getCompetitorAverages: async (campaignType: string, industry?: string) => {
    const { data, error } = await supabase
      .from('competitor_benchmarks')
      .select('average_budget')
      .eq('campaign_type', campaignType)
      .eq('industry', industry)
      .single();
    if (error) throw error;
    return data.average_budget; // 4200
  }
};
Caching Strategy: React Query, staleTime = 10min for campaign types, 5min for predictions, 2min for competitor data

Real-time Updates: Form validation with 300ms debounce, live predictions on budget/type changes

🎨 Complete UI Component Mapping
Page Header Section


UI ElementComponentData SourceImplementation"Campaign Setup" title<h1 className="text-2xl font-bold">STATIC - HardcodedCampaign Setup"Campaign Name" subtitle<p className="text-base text-gray-600">STATIC - HardcodedCampaign Name
typescript



// STATIC - No API calls needed
<div className="mb-6">
  <h1 className="text-2xl font-bold text-gray-900">Campaign Setup</h1>
  <p className="text-base text-gray-600 mt-1">Campaign Name</p>
</div>
Row 1: Campaign Name Section


UI ElementComponentData SourceImplementation"Campaign Name" label<Label htmlFor="campaign_name">STATIC - HardcodedCampaign NameText input field<Input id="campaign_name" />DYNAMIC - Form stateformData.campaign_namePlaceholder textplaceholder attributeSTATIC - Hardcoded"Interactive Stories Boost"AI suggestion chips<Badge variant="secondary">DYNAMIC - AI serviceAPI call on component mount
typescript



// HYBRID - Static UI + Dynamic data
const [formData, setFormData] = useState({ campaign_name: '' });
const [nameSuggestions, setNameSuggestions] = useState<string[]>([]);
// DYNAMIC - AI service call
useEffect(() => {
  CampaignSetupService.generateNameSuggestions(brandId)
    .then(setNameSuggestions)
    .catch(err => console.error('Failed to load suggestions:', err));
}, [brandId]);
<div>
  <Label htmlFor="campaign_name">Campaign Name</Label> {/* STATIC */}
  <Input 
    id="campaign_name"
    value={formData.campaign_name} // DYNAMIC - form state
    onChange={(e) => setFormData({...formData, campaign_name: e.target.value})}
    placeholder="Interactive Stories Boost" // STATIC
    className={errors.campaign_name ? 'border-red-500' : ''}
  />
  {/* DYNAMIC - AI suggestions */}
  <div className="mt-2 flex items-center gap-2">
    <Lightbulb className="w-4 h-4 text-yellow-500" /> {/* STATIC icon */}
    <span className="text-sm text-gray-600">AI Suggestions:</span> {/* STATIC label */}
    {nameSuggestions.map((suggestion, idx) => (
      <Badge 
        key={idx}
        variant="secondary" 
        className="cursor-pointer hover:bg-blue-100"
        onClick={() => setFormData({...formData, campaign_name: suggestion})}
      >
        {suggestion} {/* DYNAMIC from AI service */}
      </Badge>
    ))}
  </div>
</div>
Row 2: Campaign Type Selection


UI ElementComponentData SourceImplementation"Campaign Type" header<h3 className="font-semibold">STATIC - HardcodedCampaign TypeType card titles<h4> in each cardDYNAMIC - Database enum + static configDB enum + display mappingROI badges<Badge className="bg-green-500">STATIC - Configuration mappingPredefined per typeIconsLucide React iconsSTATIC - Configuration mappingIcon component per typeSelection stateBorder color classesDYNAMIC - Form stateformData.campaign_type
typescript



// HYBRID - Database enum values + static configuration
const [campaignTypes, setCampaignTypes] = useState<CampaignType[]>([]);
const [formData, setFormData] = useState({ campaign_type: '' });
// STATIC - Configuration mapping for display
const typeConfigurations = {
  engagement: { 
    label: 'Engagement', 
    roi: '+35%', 
    icon: MessageSquare,
    color: 'text-blue-600',
    bgGradient: 'from-blue-500 to-cyan-500'
  },
  awareness: { 
    label: 'Awareness', 
    icon: Eye,
    color: 'text-purple-600',
    bgGradient: 'from-purple-500 to-pink-500'
  },
  conversion: { 
    label: 'Conversion', 
    icon: Target,
    color: 'text-green-600',
    bgGradient: 'from-green-500 to-emerald-500'
  }
};
// DYNAMIC - Database fetch on component mount
useEffect(() => {
  CampaignSetupService.getCampaignTypes()
    .then(dbTypes => {
      // Combine database enum values with static configuration
      const typesWithConfig = dbTypes.map(type => ({
        value: type, // DYNAMIC from database
        ...typeConfigurations[type], // STATIC configuration
        selected: formData.campaign_type === type // DYNAMIC from form state
      }));
      setCampaignTypes(typesWithConfig);
    })
    .catch(err => {
      // Fallback to static types if database fails
      console.error('Database enum fetch failed, using fallback:', err);
      setCampaignTypes(Object.entries(typeConfigurations).map(([key, config]) => ({
        value: key,
        ...config,
        selected: formData.campaign_type === key
      })));
    });
}, [formData.campaign_type]);
<div>
  <h3 className="font-semibold mb-4">Campaign Type</h3> {/* STATIC */}
  <div className="grid grid-cols-3 gap-4">
    {campaignTypes.map(type => {
      const IconComponent = type.icon;
      return (
        <div 
          key={type.value}
          className={`rounded-lg border-2 p-4 cursor-pointer transition-all ${
            type.selected ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:border-blue-300'
          }`} // DYNAMIC - selection state
          onClick={() => setFormData({...formData, campaign_type: type.value})}
        >
          <div className="flex items-center justify-between">
            <IconComponent className="w-8 h-8" /> {/* STATIC - icon component */}
            <h4 className="font-semibold">{type.label}</h4> {/* STATIC - configuration */}
            <Badge className="bg-green-500 text-white">{type.roi}</Badge> {/* STATIC - configuration */}
          </div>
          {type.selected && <CheckCircle className="text-blue-500 mt-2" />} {/* DYNAMIC - selection indicator */}
        </div>
      );
    })}
  </div>
</div>
Row 3: Description Section


UI ElementComponentData SourceImplementation"Description" header<h3>STATIC - HardcodedDescriptionTextarea field<Textarea>DYNAMIC - Form stateformData.campaign_descriptionCharacter counter<span>DYNAMIC - Calculated from form state${length}/500AI Writing Assistant button<Button>STATIC - UI onlyButton text and icon
typescript



// DYNAMIC - Form state with calculated values
const [formData, setFormData] = useState({ campaign_description: '' });
const handleAIWritingAssist = async () => {
  // AI service integration for description generation
  try {
    const suggestions = await CampaignSetupService.generateDescription({
      campaignName: formData.campaign_name,
      campaignType: formData.campaign_type
    });
    // Show suggestions in modal or replace text
  } catch (error) {
    console.error('AI writing assistance failed:', error);
  }
};
<div>
  <h3 className="font-semibold mb-2">Description</h3> {/* STATIC */}
  <Textarea
    rows={6}
    value={formData.campaign_description} // DYNAMIC - form state
    onChange={(e) => setFormData({...formData, campaign_description: e.target.value})}
    placeholder="Describe your campaign goals..." // STATIC
    className="resize-none"
  />
  <div className="flex justify-between items-center mt-2">
    <span className="text-sm text-gray-500">
      {formData.campaign_description.length}/500 {/* DYNAMIC - calculated */}
    </span>
    <Button variant="outline" onClick={handleAIWritingAssist}>
      <Sparkles className="w-4 h-4 mr-2" /> {/* STATIC */}
      ✨ AI Writing Assistant {/* STATIC */}
    </Button>
  </div>
</div>
Row 4: Date Selection


UI ElementComponentData SourceImplementationDate labels<Label>STATIC - HardcodedStart Date, End DateDate inputs<Input type="date">DYNAMIC - Form stateformData.campaign_start_dateCalendar icons<Calendar>STATIC - Lucide iconsIcon componentsFormatted date display<span>DYNAMIC - Calculated from form stateDate formatting function
typescript



// DYNAMIC - Form state with date validation
const [formData, setFormData] = useState({
  campaign_start_date: '',
  campaign_end_date: ''
});
const formatDateDisplay = (dateString: string) => {
  if (!dateString) return '';
  return new Date(dateString).toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric', 
    year: 'numeric'
  });
};
<div className="grid grid-cols-2 gap-4">
  <div>
    <Label htmlFor="start_date">Start Date</Label> {/* STATIC */}
    <Input
      id="start_date"
      type="date"
      value={formData.campaign_start_date} // DYNAMIC
      onChange={(e) => setFormData({...formData, campaign_start_date: e.target.value})}
      min={new Date().toISOString().split('T')[0]} // DYNAMIC - today's date
      className={errors.start_date ? 'border-red-500' : ''}
    />
    <div className="flex items-center mt-1 text-sm text-gray-600">
      <Calendar className="w-4 h-4 mr-1" /> {/* STATIC */}
      <span>{formatDateDisplay(formData.campaign_start_date)}</span> {/* DYNAMIC - calculated */}
    </div>
  </div>
  <div>
    <Label htmlFor="end_date">End Date</Label> {/* STATIC */}
    <Input
      id="end_date"
      type="date"
      value={formData.campaign_end_date} // DYNAMIC
      onChange={(e) => setFormData({...formData, campaign_end_date: e.target.value})}
      min={formData.campaign_start_date || new Date().toISOString().split('T')[0]} // DYNAMIC
      className={errors.end_date ? 'border-red-500' : ''}
    />
    <div className="flex items-center mt-1 text-sm text-gray-600">
      <Calendar className="w-4 h-4 mr-1" /> {/* STATIC */}
      <span>{formatDateDisplay(formData.campaign_end_date)}</span> {/* DYNAMIC - calculated */}
    </div>
  </div>
</div>
Row 5: Optimization Tip


UI ElementComponentData SourceImplementationYellow info box<div className="bg-yellow-100">STATIC - StylingCSS classesLightbulb icon<Lightbulb>STATIC - IconLucide componentTip text<span>DYNAMIC - Based on campaign typeConfiguration mapping
typescript



// SEMI-DYNAMIC - Configuration-based tips that change with campaign type
const optimizationTips = {
  engagement: "💡 Optimal: Mondays show +25% engagement",
  awareness: "💡 Optimal: Weekends have +30% better reach",
  conversion: "💡 Optimal: Tuesday-Thursday show +40% conversions",
  default: "💡 Select a campaign type for optimization tips"
};
const currentTip = formData.campaign_type 
  ? optimizationTips[formData.campaign_type] // DYNAMIC - based on selection
  : optimizationTips.default; // STATIC fallback
<div className="bg-yellow-100 border border-yellow-200 rounded-lg p-3 flex items-center">
  <Lightbulb className="w-4 h-4 text-yellow-600 mr-2 flex-shrink-0" /> {/* STATIC */}
  <span className="text-yellow-800 text-sm">{currentTip}</span> {/* DYNAMIC */}
</div>
Row 6: Budget Section


UI ElementComponentData SourceImplementationBudget header with value<h3>DYNAMIC - Form state formattedBudget: $${value.toLocaleString()}Slider component<Slider> from shadcn/uiDYNAMIC - Form stateformData.campaign_budget_allocatedRange labels<span> elementsSTATIC - Predefined markers["$0", "$5K", "$10K+"]
typescript



// DYNAMIC - Form state with static configuration
const [formData, setFormData] = useState({ campaign_budget_allocated: 2500 });
// STATIC - Budget range configuration
const budgetConfig = {
  min: 0,
  max: 50000,
  step: 500,
  defaultValue: 2500
};
const budgetLabels = ["$0", "$5K", "$10K", "$25K", "$50K+"];
<div>
  <h3 className="font-semibold text-lg mb-4">
    Budget: ${formData.campaign_budget_allocated.toLocaleString()} {/* DYNAMIC - formatted value */}
  </h3>
  <Slider
    value={[formData.campaign_budget_allocated]} // DYNAMIC
    onValueChange={([value]) => setFormData({...formData, campaign_budget_allocated: value})}
    min={budgetConfig.min} // STATIC
    max={budgetConfig.max} // STATIC  
    step={budgetConfig.step} // STATIC
    className="mb-2"
  />
  <div className="flex justify-between">
    {budgetLabels.map(label => ( // STATIC labels
      <span key={label} className="text-sm text-gray-500">{label}</span>
    ))}
  </div>
</div>
Row 7: Performance Predictions


UI ElementComponentData SourceImplementationPredicted performance text<span>DYNAMIC - AI prediction APIAPI call based on type + budgetCompetitor average text<span>DYNAMIC - Database queryCompetitor benchmarks table
typescript



// DYNAMIC - Multiple API calls for predictions
const [predictions, setPredictions] = useState(null);
const [competitorAvg, setCompetitorAvg] = useState(null);
const [isLoadingPredictions, setIsLoadingPredictions] = useState(false);
// DYNAMIC - Trigger predictions when type or budget changes
useEffect(() => {
  if (formData.campaign_type && formData.campaign_budget_allocated > 0) {
    setIsLoadingPredictions(true);
    // Parallel API calls for predictions and competitor data
    Promise.all([
      CampaignSetupService.calculatePredictions({
        type: formData.campaign_type,
        budget: formData.campaign_budget_allocated,
        brandId: selectedBrandId
      }),
      CampaignSetupService.getCompetitorAverages(formData.campaign_type)
    ])
    .then(([predictionData, competitorData]) => {
      setPredictions(predictionData); // { reachMin: 25000, reachMax: 40000 }
      setCompetitorAvg(competitorData); // 4200
    })
    .catch(error => {
      console.error('Failed to load predictions:', error);
      // Show fallback or error state
    })
    .finally(() => {
      setIsLoadingPredictions(false);
    });
  } else {
    // Clear predictions if required data is missing
    setPredictions(null);
    setCompetitorAvg(null);
  }
}, [formData.campaign_type, formData.campaign_budget_allocated, selectedBrandId]);
<div className="grid grid-cols-2 gap-4">
  <div>
    <span className="font-medium">
      {isLoadingPredictions ? (
        <div className="flex items-center gap-2">
          <div className="animate-spin h-4 w-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>
          Loading predictions...
        </div>
      ) : predictions ? (
        `Predicted Performance: ${(predictions.reachMin / 1000).toFixed(0)}K-${(predictions.reachMax / 1000).toFixed(0)}K reach` // DYNAMIC from API
      ) : (
        "Select campaign type and budget for predictions" // STATIC fallback
      )}
    </span>
  </div>
  <div>
    <span className="text-gray-500 text-sm">
      {competitorAvg ? (
        `🏆 Competitors avg: $${competitorAvg.toLocaleString()}` // DYNAMIC from database
      ) : (
        "🏆 Competitors avg: Loading..." // STATIC loading state
      )}
    </span>
  </div>
</div>
Action Buttons Footer


UI ElementComponentData SourceImplementation"Back" button<Button variant="outline">STATIC - Always disabled on step 1Hardcoded disabled state"Continue" button<Button>STATIC - Text and iconStatic contentButton enabled statedisabled attributeDYNAMIC - Form validationCalculated from form completeness
typescript



// DYNAMIC - Form validation calculation
const isStep1Complete = useMemo(() => {
  return formData.campaign_name.trim().length >= 3 &&
         formData.campaign_type !== '' &&
         formData.campaign_start_date !== '' &&
         formData.campaign_end_date !== '' &&
         new Date(formData.campaign_start_date) < new Date(formData.campaign_end_date);
}, [formData]);
const handleContinueToStep2 = () => {
  if (isStep1Complete) {
    // Save step 1 data and proceed
    onStepComplete(formData);
    // Navigate to step 2 or update wizard state
  }
};
<div className="flex justify-between items-center p-4 border-t border-gray-200 bg-gray-50">
  <Button variant="outline" disabled> {/* STATIC - always disabled on step 1 */}
    <ArrowLeft className="w-4 h-4 mr-2" />
    Back
  </Button>
  <Button 
    className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400"
    disabled={!isStep1Complete} // DYNAMIC - validation state
    onClick={handleContinueToStep2}
  >
    Continue to Step 2 {/* STATIC */}
    <ArrowRight className="w-4 h-4 ml-2" /> {/* STATIC */}
  </Button>
</div>
📂 File Structure


apps/web/app/workspace/campaigns/
 └── create/
     └── page.tsx                    # Complete Step 1 implementation
-- Supporting API Routes --
apps/web/app/api/
 ├── ai/
 │   ├── campaign-names/route.ts     # Name suggestion endpoint
 │   └── campaign-description/route.ts # Description generation
 └── campaigns/
     └── predictions/route.ts        # Performance prediction endpoint
-- Database Functions --
migrations/
 └── campaign_setup_functions.sql   # RPC functions for enums + predictions
🧮 Business Logic & Validation
Form Validation Logic
typescript



const validateStep1 = (data: CampaignFormData) => {
  const errors: Record<string, string> = {};
  // Campaign name validation
  if (!data.campaign_name.trim()) {
    errors.campaign_name = 'Campaign name is required';
  } else if (data.campaign_name.length < 3) {
    errors.campaign_name = 'Campaign name must be at least 3 characters';
  } else if (data.campaign_name.length > 255) {
    errors.campaign_name = 'Campaign name too long (max 255 characters)';
  }
  // Campaign type validation (dynamic from database)
  if (!data.campaign_type) {
    errors.campaign_type = 'Please select a campaign type';
  }
  // Date validation with business rules
  if (!data.campaign_start_date) {
    errors.campaign_start_date = 'Start date is required';
  } else if (new Date(data.campaign_start_date) <= new Date()) {
    errors.campaign_start_date = 'Start date must be in the future';
  }
  if (!data.campaign_end_date) {
    errors.campaign_end_date = 'End date is required';
  } else if (new Date(data.campaign_end_date) <= new Date(data.campaign_start_date)) {
    errors.campaign_end_date = 'End date must be after start date';
  }
  // Budget validation (optional field)
  if (data.campaign_budget_allocated && data.campaign_budget_allocated < 0) {
    errors.campaign_budget_allocated = 'Budget cannot be negative';
  }
  return { isValid: Object.keys(errors).length === 0, errors };
};
Prediction Calculations
typescript



const calculatePredictionMetrics = (type: string, budget: number) => {
  // Base reach multipliers per campaign type
  const reachMultipliers = {
    engagement: { min: 10, max: 16 },    // Lower reach, higher engagement
    awareness: { min: 20, max: 35 },     // Higher reach, lower engagement  
    conversion: { min: 5, max: 12 }      // Lowest reach, highest conversion
  };
  const multiplier = reachMultipliers[type] || reachMultipliers.engagement;
  return {
    reachMin: Math.round(budget * multiplier.min),
    reachMax: Math.round(budget * multiplier.max),
    confidence: calculateConfidenceScore(type, budget)
  };
};
const calculateConfidenceScore = (type: string, budget: number) => {
  let baseScore = 60;
  // Type-based confidence
  const typeScores = { engagement: 75, awareness: 70, conversion: 65 };
  baseScore = typeScores[type] || 60;
  // Budget-based adjustments
  if (budget >= 10000) baseScore += 15;
  else if (budget >= 5000) baseScore += 10;
  else if (budget >= 1000) baseScore += 5;
  return Math.min(baseScore, 90); // Cap at 90%
};
🗂 State Management (Form State + React Query)
typescript



interface CampaignStep1State {
  // Form data (dynamic)
  formData: {
    campaign_name: string;
    campaign_type: string;
    campaign_description: string;
    campaign_start_date: string;
    campaign_end_date: string;
    campaign_budget_allocated: number;
  };
  // Validation state (calculated)
  errors: Record<string, string>;
  isValid: boolean;
  // UI state (dynamic)
  isSubmitting: boolean;
  showAIAssistant: boolean;
}
// React Query for server state
const useCampaignSetupData = (brandId: string) => {
  // Campaign types from database
  const campaignTypesQuery = useQuery({
    queryKey: ['campaign-types'],
    queryFn: CampaignSetupService.getCampaignTypes,
    staleTime: 10 * 60 * 1000, // Cache for 10 minutes
    retry: 2
  });
  // AI name suggestions
  const nameSuggestionsQuery = useQuery({
    queryKey: ['name-suggestions', brandId],
    queryFn: () => CampaignSetupService.generateNameSuggestions(brandId),
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes
    enabled: !!brandId
  });
  return {
    campaignTypes: campaignTypesQuery.data || [],
    nameSuggestions: nameSuggestionsQuery.data || [],
    isLoading: campaignTypesQuery.isLoading || nameSuggestionsQuery.isLoading
  };
};
⚡ Performance Requirements
Form responsiveness: < 100ms input response time for all form fields

AI suggestions loading: < 2 seconds for name suggestions API call

Campaign type loading: < 1 second for database enum fetch

Prediction calculations: < 3 seconds for performance predictions

Page initial load: < 2 seconds including all dynamic data

Responsive Layout Behavior:

Desktop ≥1280px: Two-column layout with form left, preview right

Tablet 768–1279px: Single column with stacked form sections

Mobile <768px: Full-width single column with larger touch targets

🔒 Multi-Tenancy & Security
Campaign type enum values scoped by tenant (if needed)

Brand selection limited to user's accessible brands via user_tenant_roles

All API calls include tenant context for data isolation

Input sanitization on all form fields before API calls

Rate limiting on AI service calls (5 requests/minute per user)

❌ Error Handling
Network Errors:

Campaign types: Retry 3x with exponential backoff, fallback to cached/default types

AI suggestions: Show "Suggestions unavailable" with manual input still functional

Predictions: Show "Calculations unavailable" without blocking form submission

Validation Errors:

Real-time field validation with red borders + error text below fields

Form submission blocked until all required fields valid

Clear errors immediately when user corrects input

API Failures:

Toast notifications for service unavailable

Graceful degradation (form still functional without AI features)

Automatic

🚀 Tech Story: Campaign Setup - Step 1 (Simplified Implementation)
📌 Feature Name Campaign Setup - Basic Information Step - First step of 4-step campaign creation wizard with simplified UI and form validation

🎯 Introduction The initial step of campaign creation where users enter basic campaign details including manual name input, campaign type selection from database-driven configuration, manual description entry, date selection with validation, budget slider with brand-specific currency, and static performance predictions. The interface focuses on core functionality with dummy data for intelligence components.

Business outcome: Streamlines campaign setup decisions in the first step, providing a solid foundation for the 4-step wizard process for SMEs and marketing teams.

❗ Problem Statement Users need a streamlined campaign creation process that captures essential campaign information in the first step. Current requirements focus on core functionality without AI assistance, using simplified data sources and static intelligence components.

✅ Solution Overview High-level architectural approach: Next.js 15 + Supabase + shadcn/ui + React Query + Form validation

Key principles:

Manual user input (no AI assistance in Phase 1)

Database-driven campaign types with dummy data

Brand-specific currency handling

Static dummy data for intelligence components

Form validation and state management

🛠️ Technical Architecture

Data Layer
Primary Tables:

campaigns - Will store completed campaign data after all 4 steps

brands - For brand association, tenant scoping, and currency settings

user_tenant_roles - User permission and tenant access

campaign_drafts

Database Configuration:

Campaign types table/view with ROI details and icon names (dummy data)

Brand currency settings enhancement needed

Currency conversion logic for future implementation

Key Relationships:



campaigns.brand_id → brands.id
campaigns.tenant_id → tenants.id
user_tenant_roles.tenant_id → tenants.id
API Layer Architecture
Service Classes:



import { supabase } from './supabaseClient';
export const CampaignSetupService = {
  /**
   * Fetches campaign types and their calculated ROI from the database view.
   * This function makes a single query to get all necessary data for the UI.
   *
   * @returns {Array<Object>} An array of campaign type objects with dynamic ROI data.
   */
  getCampaignTypes: async () => {
    try {
      const { data, error } = await supabase
        .from('view_campaign_type_roi')
        .select('campaign_type_slug, campaign_type_name, icon_name, average_roi_percentage');
      if (error) {
        console.error('Error fetching campaign types:', error.message);
        throw error;
      }
      // Map the view's columns to the UI's expected format
      const formattedData = data.map(item => ({
        type: item.campaign_type_slug,
        label: item.campaign_type_name,
        roi_percentage: Math.round(item.average_roi_percentage),
        icon_name: item.icon_name
      }));
      return formattedData;
    } catch (error) {
      console.error('Failed to get campaign types.', error);
      return [];
    }
  },
};
  // DYNAMIC - Brand currency settings
  getBrandCurrency: async (brandId: string) => {
    const { data, error } = await supabase
      .from('brands')
      .select('currency_code, currency_symbol')
      .eq('id', brandId)
      .single();
    if (error) throw error;
    return data; // { currency_code: "USD", currency_symbol: "$" }
  },
  // STATIC - Dummy competitor data
  getCompetitorAverages: () => {
    return Promise.resolve(4200); // Static dummy value
  }
};
Campain Draft



export const CampaignDraftService = {
  saveDraft: async (draftPayload: CampaignDraftPayload) => {
    const { data, error } = await supabase
      .from('campaign_drafts')
      .upsert({
        ...draftPayload,
        last_updated: new Date().toISOString()
      })
      .select('*, brands(name)');
    if (error) throw error;
    return data;
  },
  fetchByIndustryAndDrafts: async (industryId: string, tenantId: string, includeDrafts = false) => {
    // First get templates
    let templateQuery = supabase
      .from('templates') // Assuming you have this
      .select('*')
      .eq('industry_id', industryId);
    // Then get drafts if requested
    let draftQuery = null;
    if (includeDrafts) {
      draftQuery = supabase
        .from('campaign_drafts')
        .select('*, brands(name, industry_id)')
        .eq('tenant_id', tenantId)
        .eq('draft_status', 'in_progress');
    }
    const [templateResult, draftResult] = await Promise.all([
      templateQuery,
      draftQuery
    ]);
    return {
      templates: templateResult.data || [],
      drafts: draftResult?.data || []
    };
  },
  linkToInsight: async (draftId: string, insightId: string) => {
    const { error } = await supabase
      .from('campaign_drafts')
      .update({ 
        source_insight_id: insightId,
        last_updated: new Date().toISOString()
      })
      .eq('id', draftId);
    if (error) throw error;
  }
};
AI Insights Integration



Caching Strategy: React Query, staleTime = 12hr for campaign types, 24hr for brand currency

Real-time Updates: Form validation with 300ms debounce on input fields

🎨 Complete UI Component Mapping

Page Header Section
UI Element

Component

Data Source

Implementation

"Campaign Setup" title

<h1>

STATIC - Hardcoded

Campaign Setup

"Step 1 of 4" subtitle

<p>

STATIC - Hardcoded

Step 1 of 4: Basic Information



// STATIC - No API calls needed
<div className="mb-6">
  <h1 className="text-2xl font-bold text-gray-900">Campaign Setup</h1>
  <p className="text-base text-gray-600 mt-1">Step 1 of 4: Basic Information</p>
</div>
Row 1: Campaign Name Section
UI Element

Component

Data Source

Implementation

"Campaign Name" label

<Label>

STATIC - Hardcoded

Campaign Name

Text input field

<Input>

DYNAMIC - Form state

formData.campaign_name

Placeholder text

placeholder attribute

STATIC - Hardcoded

"Enter campaign name..."



// DYNAMIC - Form state only, no AI suggestions
const [formData, setFormData] = useState({ campaign_name: '' });
<div>
  <Label htmlFor="campaign_name">Campaign Name</Label> {/* STATIC */}
  <Input 
    id="campaign_name"
    value={formData.campaign_name} // DYNAMIC - form state
    onChange={(e) => setFormData({...formData, campaign_name: e.target.value})}
    placeholder="Enter campaign name..." // STATIC
    className={errors.campaign_name ? 'border-red-500' : ''}
  />
  {errors.campaign_name && (
    <p className="text-sm text-red-500 mt-1">{errors.campaign_name}</p>
  )}
</div>
Row 2: Campaign Type Selection
UI Element

Component

Data Source

Implementation

"Campaign Type" header

<h3>

STATIC - Hardcoded

Campaign Type

Type cards

<div> grid

DYNAMIC - Database + static config

Database query + icon mapping

ROI badges

<Badge>

DYNAMIC - Database

From campaign_types_config table

Icons

Lucide React icons

STATIC - Configuration mapping

Icon name from database

Selection state

Border color classes

DYNAMIC - Form state

formData.campaign_type



// HYBRID - Database values + static configuration
const [campaignTypes, setCampaignTypes] = useState<CampaignType[]>([]);
// STATIC - Icon mapping configuration
const iconMap = {
  MessageSquare: MessageSquare,
  Eye: Eye,
  Target: Target
};
// DYNAMIC - Database fetch on component mount
useEffect(() => {
  CampaignSetupService.getCampaignTypes()
    .then(dbTypes => {
      const typesWithIcons = dbTypes.map(type => ({
        ...type,
        IconComponent: iconMap[type.icon_name],
        selected: formData.campaign_type === type.type
      }));
      setCampaignTypes(typesWithIcons);
    })
    .catch(err => console.error('Failed to load campaign types:', err));
}, [formData.campaign_type]);
<div>
  <h3 className="font-semibold mb-4">Campaign Type</h3> {/* STATIC */}
  <div className="grid grid-cols-3 gap-4">
    {campaignTypes.map(type => {
      const IconComponent = type.IconComponent;
      return (
        <div 
          key={type.type}
          className={`rounded-lg border-2 p-4 cursor-pointer transition-all ${
            type.selected ? 'border-blue-500 bg-blue-50' : 'border-gray-200 hover:border-blue-300'
          }`}
          onClick={() => setFormData({...formData, campaign_type: type.type})}
        >
          <div className="flex flex-col items-center text-center">
            <IconComponent className="w-8 h-8 mb-2" />
            <h4 className="font-semibold">{type.label}</h4>
            <Badge className="bg-green-500 text-white mt-2">
              ROI: +{type.roi_percentage}%
            </Badge>
            <p className="text-sm text-gray-600 mt-2">{type.description}</p>
          </div>
          {type.selected && <CheckCircle className="text-blue-500 mt-2 mx-auto" />}
        </div>
      );
    })}
  </div>
</div>
Row 3: Description Section
UI Element

Component

Data Source

Implementation

"Description" header

<h3>

STATIC - Hardcoded

Description

Textarea field

<Textarea>

DYNAMIC - Form state

formData.campaign_description

Character counter

<span>

DYNAMIC - Calculated

${length}/500



// DYNAMIC - Form state only, no AI assistance
const [formData, setFormData] = useState({ campaign_description: '' });
<div>
  <h3 className="font-semibold mb-2">Description</h3> {/* STATIC */}
  <Textarea
    rows={6}
    value={formData.campaign_description} // DYNAMIC - form state
    onChange={(e) => setFormData({...formData, campaign_description: e.target.value})}
    placeholder="Describe your campaign goals..." // STATIC
    className="resize-none"
  />
  <div className="flex justify-end mt-2">
    <span className="text-sm text-gray-500">
      {formData.campaign_description.length}/500 {/* DYNAMIC - calculated */}
    </span>
  </div>
</div>
Row 4: Date Selection
UI Element

Component

Data Source

Implementation

Date labels

<Label>

STATIC - Hardcoded

Start Date, End Date

Date inputs

<Input type="date">

DYNAMIC - Form state

formData.start_date, formData.end_date

Max date constraint

max attribute

DYNAMIC - Calculated

1 year from now



// DYNAMIC - Form state with date validation
const [formData, setFormData] = useState({
  campaign_start_date: '',
  campaign_end_date: ''
});
const maxDate = new Date();
maxDate.setFullYear(maxDate.getFullYear() + 1);
const maxDateString = maxDate.toISOString().split('T')[0];
<div className="grid grid-cols-2 gap-4">
  <div>
    <Label htmlFor="start_date">Start Date</Label> {/* STATIC */}
    <Input
      id="start_date"
      type="date"
      value={formData.campaign_start_date} // DYNAMIC
      onChange={(e) => setFormData({...formData, campaign_start_date: e.target.value})}
      min={new Date().toISOString().split('T')[0]} // DYNAMIC - today's date
      max={maxDateString} // DYNAMIC - 1 year from now
      className={errors.start_date ? 'border-red-500' : ''}
    />
  </div>
  <div>
    <Label htmlFor="end_date">End Date</Label> {/* STATIC */}
    <Input
      id="end_date"
      type="date"
      value={formData.campaign_end_date} // DYNAMIC
      onChange={(e) => setFormData({...formData, campaign_end_date: e.target.value})}
      min={formData.campaign_start_date || new Date().toISOString().split('T')[0]} // DYNAMIC
      max={maxDateString} // DYNAMIC - 1 year from now
      className={errors.end_date ? 'border-red-500' : ''}
    />
  </div>
</div>
Row 5: Budget Section
UI Element

Component

Data Source

Implementation

Budget header with value

<h3>

DYNAMIC - Form state + brand currency

Budget: ${currency_symbol}${value.toLocaleString()}

Slider component

<Slider>

DYNAMIC - Form state

formData.campaign_budget_allocated

Currency handling

Text formatting

DYNAMIC - Brand store

From brand currency settings



// DYNAMIC - Form state with brand currency integration
const [formData, setFormData] = useState({ campaign_budget_allocated: 2500 });
const [brandCurrency, setBrandCurrency] = useState({ symbol: '$', code: 'USD' });
// DYNAMIC - Load brand currency settings
useEffect(() => {
  if (selectedBrandId) {
    CampaignSetupService.getBrandCurrency(selectedBrandId)
      .then(currency => setBrandCurrency({
        symbol: currency.currency_symbol,
        code: currency.currency_code
      }))
      .catch(() => setBrandCurrency({ symbol: '$', code: 'USD' })); // Fallback
  }
}, [selectedBrandId]);
<div>
  <h3 className="font-semibold text-lg mb-4">
    Budget: {brandCurrency.symbol}{formData.campaign_budget_allocated.toLocaleString()} {brandCurrency.code} 
    {/* DYNAMIC - formatted value with brand currency */}
  </h3>
  <Slider
    value={[formData.campaign_budget_allocated]} // DYNAMIC
    onValueChange={([value]) => setFormData({...formData, campaign_budget_allocated: value})}
    min={0} // STATIC
    max={50000} // STATIC  
    step={500} // STATIC
    className="mb-2"
  />
  <div className="flex justify-between">
    <span className="text-sm text-gray-500">{brandCurrency.symbol}0</span>
    <span className="text-sm text-gray-500">{brandCurrency.symbol}50K+</span>
  </div>
</div>
Row 6: Intelligence Components (Dummy Data)
AI Suggested Actions Panel


// STATIC - Dummy data for now
const dummyAISuggestions = [
  {
    title: "Increase Instagram engagement with polls",
    impact: "High",
    confidence: "87%",
    description: "Based on your campaign type, interactive polls could boost engagement by 35%"
  }
];
<div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
  <h3 className="font-semibold mb-3 flex items-center">
    <Brain className="w-5 h-5 mr-2 text-blue-600" />
    AI Suggested Actions
  </h3>
  {dummyAISuggestions.map((suggestion, index) => (
    <div key={index} className="bg-white p-3 rounded border">
      <div className="flex justify-between items-start mb-2">
        <h4 className="font-medium">{suggestion.title}</h4>
        <Badge variant="outline">{suggestion.confidence} confidence</Badge>
      </div>
      <p className="text-sm text-gray-600">{suggestion.description}</p>
      <Badge className="mt-2 bg-orange-100 text-orange-800">{suggestion.impact} Impact</Badge>
    </div>
  ))}
</div>
Trending Topics Panel


// STATIC - Dummy data for now
const dummyTrendingTopics = [
  { name: "#BackToSchool", growth: "+45%", volume: "2.3M" },
  { name: "#SustainableFashion", growth: "+32%", volume: "890K" },
  { name: "#WFHLife", growth: "+28%", volume: "1.5M" }
];
<div className="bg-orange-50 border border-orange-200 rounded-lg p-4">
  <h3 className="font-semibold mb-3 flex items-center">
    <TrendingUp className="w-5 h-5 mr-2 text-orange-600" />
    Trending Topics
  </h3>
  {dummyTrendingTopics.map((trend, index) => (
    <div key={index} className="flex justify-between items-center py-2 border-b border-orange-100 last:border-b-0">
      <span className="font-medium">{trend.name}</span>
      <div className="text-right">
        <span className="text-green-600 text-sm font-medium">{trend.growth}</span>
        <div className="text-xs text-gray-500">{trend.volume}</div>
      </div>
    </div>
  ))}
</div>
Competitor Intelligence Panel


// STATIC - Dummy data for now
const dummyCompetitorData = {
  activeCampaigns: 3,
  avgSpend: 4200,
  topContentType: "Video testimonials"
};
<div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
  <h3 className="font-semibold mb-3 flex items-center">
    <Target className="w-5 h-5 mr-2 text-purple-600" />
    Competitor Intelligence
  </h3>
  <div className="grid grid-cols-2 gap-4">
    <div className="text-center">
      <div className="text-2xl font-bold text-purple-700">{dummyCompetitorData.activeCampaigns}</div>
      <div className="text-sm text-gray-600">Active Campaigns</div>
    </div>
    <div className="text-center">
      <div className="text-2xl font-bold text-purple-700">${(dummyCompetitorData.avgSpend / 1000).toFixed(1)}K</div>
      <div className="text-sm text-gray-600">Avg Spend</div>
    </div>
  </div>
  <div className="mt-3 pt-3 border-t border-purple-200">
    <span className="text-sm font-medium">Top Content: </span>
    <span className="text-sm text-gray-600">{dummyCompetitorData.topContentType}</span>
  </div>
</div>
Audience Sentiment Panel


// STATIC - Dummy data for now
const dummySentimentData = {
  positive: 68,
  neutral: 24,
  negative: 8
};
<div className="bg-green-50 border border-green-200 rounded-lg p-4">
  <h3 className="font-semibold mb-3 flex items-center">
    <MessageSquare className="w-5 h-5 mr-2 text-green-600" />
    Audience Sentiment
  </h3>
  <div className="space-y-2">
    <div className="flex items-center justify-between">
      <span className="text-sm">Positive</span>
      <span className="text-sm font-medium text-green-600">{dummySentimentData.positive}%</span>
    </div>
    <div className="w-full bg-gray-200 rounded-full h-2">
      <div className="bg-green-500 h-2 rounded-full" style={{width: `${dummySentimentData.positive}%`}}></div>
    </div>
    <div className="flex items-center justify-between">
      <span className="text-sm">Neutral</span>
      <span className="text-sm font-medium text-gray-600">{dummySentimentData.neutral}%</span>
    </div>
    <div className="w-full bg-gray-200 rounded-full h-2">
      <div className="bg-gray-400 h-2 rounded-full" style={{width: `${dummySentimentData.neutral}%`}}></div>
    </div>
    <div className="flex items-center justify-between">
      <span className="text-sm">Negative</span>
      <span className="text-sm font-medium text-red-600">{dummySentimentData.negative}%</span>
    </div>
    <div className="w-full bg-gray-200 rounded-full h-2">
      <div className="bg-red-500 h-2 rounded-full" style={{width: `${dummySentimentData.negative}%`}}></div>
    </div>
  </div>
</div>
Action Buttons Footer with Draft Storage
UI Element

Component

Data Source

Implementation

"Back" button

<Button variant="outline">

STATIC - Always disabled on step 1

Hardcoded disabled state

"Save Draft" button

<Button variant="outline">

DYNAMIC - Form state + API

Optional explicit save without navigation

"Continue" button

<Button>

DYNAMIC - Form validation + draft save

Auto-saves draft then navigates to step 2



// DYNAMIC - Form validation calculation with draft storage
const [isSubmitting, setIsSubmitting] = useState(false);
const [existingDraft, setExistingDraft] = useState(null);
const isStep1Complete = useMemo(() => {
  return formData.campaign_name.trim().length >= 3 &&
         formData.campaign_type !== '' &&
         formData.campaign_start_date !== '' &&
         formData.campaign_end_date !== '' &&
         new Date(formData.campaign_start_date) < new Date(formData.campaign_end_date);
}, [formData]);
// DYNAMIC - Save draft without navigation
const handleSaveDraft = async () => {
  setIsSubmitting(true);
  try {
    const draftData = {
      campaign_name: formData.campaign_name,
      campaign_type: formData.campaign_type,
      campaign_description: formData.campaign_description,
      campaign_start_date: formData.campaign_start_date,
      campaign_end_date: formData.campaign_end_date,
      campaign_budget_allocated: formData.campaign_budget_allocated,
      step_completed: 1,
      brand_id: selectedBrandId,
      tenant_id: currentTenantId,
      source_insight_id: brandHealthContext?.insightId,
      draft_status: 'in_progress'
    };
    const { error } = await supabase
      .from('campaign_drafts')
      .upsert(draftData, { onConflict: 'brand_id,created_by' });
    if (error) throw error;
    toast.success('Draft saved successfully');
  } catch (error) {
    console.error('Failed to save draft:', error);
    toast.error('Failed to save draft');
  } finally {
    setIsSubmitting(false);
  }
};
// DYNAMIC - Save draft and navigate to step 2
const handleContinueToStep2 = async () => {
  if (!isStep1Complete) return;
  setIsSubmitting(true);
  try {
    const draftData = {
      campaign_name: formData.campaign_name,
      campaign_type: formData.campaign_type,
      campaign_description: formData.campaign_description,
      campaign_start_date: formData.campaign_start_date,
      campaign_end_date: formData.campaign_end_date,
      campaign_budget_allocated: formData.campaign_budget_allocated,
      step_completed: 1,
      brand_id: selectedBrandId,
      tenant_id: currentTenantId,
      source_insight_id: brandHealthContext?.insightId,
      draft_status: 'step_1_complete'
    };
    const { data: draft, error } = await supabase
      .from('campaign_drafts')
      .upsert(draftData, { onConflict: 'brand_id,created_by' })
      .select()
      .single();
    if (error) throw error;
    // Navigate with draft ID for step 2
    router.push(`/workspace/campaigns/create/step-2?draft_id=${draft.id}`);
  } catch (error) {
    console.error('Failed to save draft:', error);
    toast.error('Draft save failed, but continuing to next step');
    router.push('/workspace/campaigns/create/step-2');
  } finally {
    setIsSubmitting(false);
  }
};
<div className="flex justify-between items-center p-4 border-t border-gray-200 bg-gray-50">
  <Button variant="outline" disabled> {/* STATIC - always disabled on step 1 */}
    <ArrowLeft className="w-4 h-4 mr-2" />
    Back
  </Button>
  <div className="flex items-center gap-3">
    {/* DYNAMIC - Optional explicit draft save */}
    <Button 
      variant="outline"
      onClick={handleSaveDraft}
      disabled={isSubmitting || Object.keys(formData).every(key => !formData[key])}
      className="text-gray-600 hover:text-gray-800"
    >
      {isSubmitting ? (
        <>
          <Loader2 className="w-4 h-4 mr-2 animate-spin" />
          Saving...
        </>
      ) : (
        <>
          <Save className="w-4 h-4 mr-2" />
          Save Draft
        </>
      )}
    </Button>
    {/* DYNAMIC - Continue with auto-draft save */}
    <Button 
      className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400"
      disabled={!isStep1Complete || isSubmitting} // DYNAMIC - validation + submission state
      onClick={handleContinueToStep2}
    >
      {isSubmitting ? (
        <>
          <Loader2 className="w-4 h-4 mr-2 animate-spin" />
          Saving & Continuing...
        </>
      ) : (
        <>
          Continue to Step 2 {/* STATIC */}
          <ArrowRight className="w-4 h-4 ml-2" /> {/* STATIC */}
        </>
      )}
    </Button>
  </div>
</div>
Key Enhancements:

Draft Storage: Both buttons interact with campaign_drafts table

Save Draft: Explicit save without navigation, disabled when form is empty

Continue Button: Auto-saves draft with step_1_complete status then navigates

Loading States: Shows spinner and loading text during API calls

Error Handling: Graceful fallback if draft save fails

Toast Notifications: User feedback for save success/failure

Draft Recovery: Step 2 can load draft using draft_id parameter

📂 File Structure



apps/web/app/workspace/campaigns/
 └── create/
     └── page.tsx                    # Complete Step 1 implementation
     └── [id]/edit/page.tsx
-- Components --
packages/ui/src/components/campaigns/
 ├── campaign-name-input.tsx
 ├── campaign-type-selector.tsx
 ├── campaign-description-input.tsx
 ├── date-range-picker.tsx
 ├── budget-slider.tsx
 └── intelligence-panels.tsx
🧮 Business Logic & Validation

Form Validation Logic


const validateStep1 = (data: CampaignFormData) => {
  const errors: Record<string, string> = {};
  // Campaign name validation
  if (!data.campaign_name.trim()) {
    errors.campaign_name = 'Campaign name is required';
  } else if (data.campaign_name.length < 3) {
    errors.campaign_name = 'Campaign name must be at least 3 characters';
  }
  // Campaign type validation
  if (!data.campaign_type) {
    errors.campaign_type = 'Please select a campaign type';
  }
  // Date validation
  if (!data.campaign_start_date) {
    errors.campaign_start_date = 'Start date is required';
  }
  if (!data.campaign_end_date) {
    errors.campaign_end_date = 'End date is required';
  } else if (new Date(data.campaign_end_date) <= new Date(data.campaign_start_date)) {
    errors.campaign_end_date = 'End date must be after start date';
  }
  // Check if end date is more than 1 year from now
  const maxDate = new Date();
  maxDate.setFullYear(maxDate.getFullYear() + 1);
  if (new Date(data.campaign_end_date) > maxDate) {
    errors.campaign_end_date = 'Campaign cannot extend more than 1 year from now';
  }
  return { isValid: Object.keys(errors).length === 0, errors };
};
Currency Handling Logic


const formatCurrency = (amount: number, currencyCode: string, currencySymbol: string) => {
  return `${currencySymbol}${amount.toLocaleString()} ${currencyCode}`;
};
// Future enhancement: Currency conversion
const convertCurrency = async (amount: number, fromCode: string, toCode: string) => {
  // Implementation for future currency conversion
  // For now, return amount as-is
  return amount;
};
🗂 State Management (Form State + React Query)



interface CampaignStep1State {
  // Form data (dynamic)
  formData: {
    campaign_name: string;
    campaign_type: string;
    campaign_description: string;
    campaign_start_date: string;
    campaign_end_date: string;
    campaign_budget_allocated: number;
  };
  // Validation state (calculated)
  errors: Record<string, string>;
  isValid: boolean;
  // UI state (dynamic)
  isSubmitting: boolean;
}
// React Query for server state
const useCampaignSetupData = (brandId: string) => {
  // Campaign types from database
  const campaignTypesQuery = useQuery({
    queryKey: ['campaign-types'],
    queryFn: CampaignSetupService.getCampaignTypes,
    staleTime: 10 * 60 * 1000, // Cache for 10 minutes
    retry: 2
  });
  // Brand currency settings
  const brandCurrencyQuery = useQuery({
    queryKey: ['brand-currency', brandId],
    queryFn: () => CampaignSetupService.getBrandCurrency(brandId),
    staleTime: 30 * 60 * 1000, // Cache for 30 minutes
    enabled: !!brandId
  });
  return {
    campaignTypes: campaignTypesQuery.data || [],
    brandCurrency: brandCurrencyQuery.data || { symbol: '$', code: 'USD' },
    isLoading: campaignTypesQuery.isLoading || brandCurrencyQuery.isLoading
  };
};
⚡ Performance Requirements

Form responsiveness: < 100ms input response time for all form fields

Campaign type loading: < 1 second for database query

Page initial load: < 2 seconds including all static dummy data

Currency loading: < 500ms for brand currency settings

Responsive Layout Behavior:

Desktop ≥1280px: Two-column layout (form left, intelligence panels right)

Tablet 768–1279px: Single column with stacked sections

Mobile <768px: Full-width single column with collapsible panels

🔒 Multi-Tenancy & Security

Campaign type configuration scoped by tenant (if needed)

Brand selection limited to user's accessible brands via user_tenant_roles

All form submissions include tenant context for data isolation

Input sanitization on all form fields before submission

❌ Error Handling Network Errors:

Campaign types: Show fallback default types if database fails

Brand currency: Fallback to USD/$1.00 if currency settings unavailable

Form submission: Clear error messaging with retry options

Validation Errors:

Real-time field validation with red borders + error text below fields

Form submission blocked until all required fields valid

Clear errors immediately when user corrects input

Data Failures:

Intelligence panels show "Data unavailable" state gracefully

Form remains functional even if dummy data fails to load

No blocking errors for non-critical components

🧭 Navigation




  { label: 'Create Campaign', href: '/workspace/campaigns/create', current: true },
Navigation Flow:
User clicks "Create Campaign" on any insight in brand health dashboard

URL parameters passed:



/workspace/campaigns/create?source=brand-health&insight_id=1&category=sentiment&suggested_name=Sentiment%20Campaign%20-%20Jan%202025&context=Negative%20themes%20around%20sizing&suggested_type=engagement
Campaign creation page:

Shows blue alert: "Smart Campaign Creation: We've pre-filled some details..."

Pre-fills campaign name, description, and suggests campaign type

User can modify or accept suggestions

dim_campaign_type (New Table):

Purpose: This will replace the static typeConfigurations object in the front end. It will store the canonical list of campaign types and their display properties.

Columns:

id (uuid, Primary Key)

name (varchar, e.g., 'Engagement', 'Awareness', 'Conversion')

slug (varchar, unique, e.g., 'engagement', 'awareness', 'conversion')

description (text)

icon (text, stores the icon name or path)

color (text, stores the Tailwind CSS class or hex code)

bg_gradient (text, stores the Tailwind CSS class or gradient string)

primary_metric_type_id (uuid, Foreign Key to dim_metric_type.id)

created_at (timestamp with time zone)

updated_at (timestamp with time zone)



CREATE TABLE public.dim_campaign_type (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    name character varying NOT NULL,
    slug character varying NOT NULL UNIQUE,
    description text NULL,
    icon text NULL,
    color text NULL,
    bg_gradient text NULL,
    primary_metric_type_id uuid NOT NULL,
    created_at timestamp with time zone NULL DEFAULT now(),
    updated_at timestamp with time zone NULL DEFAULT now(),
    CONSTRAINT dim_campaign_type_pkey PRIMARY KEY (id),
    CONSTRAINT dim_campaign_type_primary_metric_type_fkey FOREIGN KEY (primary_metric_type_id) REFERENCES public.dim_metric_type(id)
) TABLESPACE pg_default;
-- Create an index for faster lookups on the slug, which will be used for display mapping
CREATE INDEX idx_dim_campaign_type_slug ON public.dim_campaign_type (slug);
 



-- Assuming metric_type IDs for these codes exist in dim_metric_type
INSERT INTO public.dim_campaign_type (name, slug, icon, color, bg_gradient, primary_metric_type_id) VALUES
('Engagement', 'engagement', 'MessageSquare', 'text-blue-600', 'from-blue-500 to-cyan-500', (SELECT id FROM public.dim_metric_type WHERE code = 'engagement_rate')),
('Awareness', 'awareness', 'Eye', 'text-purple-600', 'from-purple-500 to-pink-500', (SELECT id FROM public.dim_metric_type WHERE code = 'total_reach')),
('Conversion', 'conversion', 'Target', 'text-green-600', 'from-green-500 to-emerald-500', (SELECT id FROM public.dim_metric_type WHERE code = 'conversions'));

unified_performance_metrics_v1



By GenAIWorkggn

1 min

See views

Add a reaction
unified_performance_metrics_v1 (New Table)
 

Purpose: This new table is a streamlined version of the original, specifically optimized for tracking and analyzing the performance of individual campaigns. It focuses on key metrics required for calculating ROI and evaluating the success of campaigns, rather than general brand health. This design supports the dynamic ROI calculation by directly linking performance data to a specific campaign_id.

Columns:

id (uuid, Primary Key): A unique identifier for each metric record.

tenant_id (uuid, Foreign Key): Links the performance data to the top-level tenant.

brand_id (uuid, Foreign Key): Links the metrics to a specific brand.

campaign_id (uuid, Foreign Key): The crucial new link that directly ties this performance data to a specific campaign in the campaigns table.

metric_date (date): The date for which these performance metrics were recorded.

platform (varchar): The marketing or social media platform where the campaign was run (e.g., 'Facebook', 'Instagram', 'Google Ads').

metric_category (varchar): Defines the metric type, such as 'Social' or 'Paid Media'.

total_reach (bigint): The total unique number of people who saw the campaign content.

total_impressions (bigint): The total number of times the content was displayed.

total_likes (integer): The total number of likes received by the campaign's content.

total_comments (integer): The total number of comments received.

total_shares (integer): The total number of shares of the content.

total_saves (integer): The total number of saves or bookmarks.

average_engagement_rate (numeric): The calculated rate of user interaction with the campaign's content.

attributed_revenue (numeric): The revenue directly attributed to the campaign's efforts.

marketing_spend (numeric): The total budget spent on the campaign.

conversions (integer): The number of desired actions (e.g., sign-ups, sales) generated by the campaign.

sessions (integer): The number of user sessions or visits generated by the campaign.

created_at (timestamp with time zone): The timestamp when the record was created.

updated_at (timestamp with time zone): The timestamp when the record was last updated.

campaigns



By GenAIWorkggn

2 min

See views

Add a reaction
campaigns Table Documentation
 

Purpose: This table serves as the central repository for all marketing campaigns within a brand. It stores the campaign's metadata, including its goals, budget, timeline, and status. The table is designed to track a campaign's lifecycle from inception to completion and provides the foundational data for performance analysis and ROI calculation.

Key Relationships:

brands: A campaign belongs to a single brand.

tenants: All campaigns are associated with a tenant for multi-tenancy.

users: Tracks who created and last updated the campaign for accountability.

unified_performance_metrics_v1: Performance data is linked back to this table via campaign_id to enable detailed ROI and metric analysis.

ai_recommended_actions_v1: Actions can be assigned to a specific campaign.

Columns:

id (uuid, Primary Key): A unique, system-generated identifier for each campaign.

tenant_id (uuid, Foreign Key): The ID of the tenant to which the campaign belongs.

brand_id (uuid, Foreign Key): The ID of the brand for which the campaign is running.

campaign_name (varchar(255)): A human-readable name for the campaign.

campaign_description (text): A detailed description of the campaign's purpose, strategy, and target audience.

campaign_type (public.campaign_type_enum): The strategic type of the campaign (e.g., 'engagement', 'conversion'). It's recommended to migrate this to a foreign key to a dim_campaign_type table for a more flexible and robust data model.

campaign_status (public.campaign_status_enum, default 'draft'): The current state of the campaign's lifecycle (e.g., 'draft', 'active', 'completed').

campaign_start_date (timestamp with time zone): The planned start date of the campaign.

campaign_end_date (timestamp with time zone): The planned end date of the campaign.

campaign_budget_allocated (numeric): The total budget assigned to the campaign.

campaign_goals (jsonb, default '{}'): A flexible JSON object to store specific, custom goals for the campaign.

campaign_confidence_score (numeric): An AI-generated score representing the model's confidence in the campaign's success.

campaign_predicted_reach_min (integer): The minimum predicted reach based on campaign parameters.

campaign_predicted_reach_max (integer): The maximum predicted reach based on campaign parameters.

created_at (timestamp with time zone): The timestamp when the campaign record was created.

updated_at (timestamp with time zone): The timestamp of the last update to the record.

created_by (uuid, Foreign Key): The user who created the campaign.

updated_by (uuid, Foreign Key): The user who last updated the campaign.

is_deleted (boolean, default false): A soft-delete flag to logically remove records without deleting them from the database.

Constraints:

campaigns_pkey: Defines id as the primary key.

campaigns_brand_fkey: Ensures brand_id references a valid brand in the brands table.

campaigns_created_by_fkey: Ensures created_by references a valid user.

campaigns_tenant_fkey: Ensures tenant_id references a valid tenant.

campaigns_updated_by_fkey: Ensures updated_by references a valid user.

campaigns_campaign_budget_allocated_check: A check constraint to ensure the budget is either NULL or a positive value.

campaigns_campaign_confidence_score_check: A check constraint to ensure the confidence score is between 0 and 100.

campaigns_reach_check: Ensures campaign_predicted_reach_min is not greater than campaign_predicted_reach_max.

campaigns_date_check: Ensures campaign_start_date is before campaign_end_date.

Indexes:

idx_campaigns_tenant_brand: A B-tree index on tenant_id and brand_id for efficient filtering on campaign lists per tenant or brand.

idx_campaigns_status: A B-tree index on campaign_status to quickly retrieve campaigns by their status.

idx_campaigns_created_at: A B-tree index for ordering campaigns by creation date.

idx_campaigns_dates: A B-tree index to optimize queries that filter on campaign start and end dates.

idx_campaigns_brand: A B-tree index on brand_id for faster lookups of campaigns for a specific brand.

few db query

select * from view_campaign_type_roi

| campaign_type_id                     | campaign_type_name | campaign_type_slug | icon_name     | color           | bg_gradient                   | average_roi_percentage  |
| ------------------------------------ | ------------------ | ------------------ | ------------- | --------------- | ----------------------------- | ----------------------- |
| b563fa25-3fbc-423c-99af-80efdf8de313 | Conversion         | conversion         | Target        | text-green-600  | from-green-500 to-emerald-500 | 55.55555555555555555567 |
| eb8f694b-2bea-49e7-900f-106cd18f1da3 | Engagement         | engagement         | MessageSquare | text-blue-600   | from-blue-500 to-cyan-500     | 62.50000000000000000000 |
| fa674002-c3db-450a-b612-e3c1293665c3 | Awareness          | awareness          | Eye           | text-purple-600 | from-purple-500 to-pink-500   | 25.00000000000000000000 |

select currency_code, currency_symbol,slug from brands where id='4743e593-3f09-4eba-96b4-c4c1413bca47'

| currency_code | currency_symbol | slug       |
| ------------- | --------------- | ---------- |
| INR           | Rs              | fitleasure |

create table public.campaign_drafts (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  brand_id uuid not null,
  created_by uuid not null,
  campaign_name character varying null,
  campaign_type character varying null,
  campaign_description text null,
  campaign_start_date timestamp with time zone null,
  campaign_end_date timestamp with time zone null,
  campaign_budget_allocated numeric null,
  campaign_platforms jsonb null default '[]'::jsonb,
  campaign_content jsonb null default '{}'::jsonb,
  campaign_targeting jsonb null default '{}'::jsonb,
  step_completed integer null default 1,
  draft_status character varying null default 'in_progress'::character varying,
  source_insight_id uuid null,
  last_updated timestamp with time zone null default now(),
  created_at timestamp with time zone null default now(),
  expires_at timestamp with time zone null default (now() + '30 days'::interval),
  constraint campaign_drafts_pkey primary key (id),
  constraint campaign_drafts_brand_fkey foreign KEY (brand_id) references brands (id),
  constraint campaign_drafts_created_by_fkey foreign KEY (created_by) references auth.users (id),
  constraint campaign_drafts_tenant_fkey foreign KEY (tenant_id) references tenants (id)
) TABLESPACE pg_default;

create view public.view_campaign_type_roi as
select
  dct.id as campaign_type_id,
  dct.name as campaign_type_name,
  dct.slug as campaign_type_slug,
  dct.icon as icon_name,
  dct.color,
  dct.bg_gradient,
  avg(
    case
      when upm.marketing_spend > 0::numeric then (upm.attributed_revenue - upm.marketing_spend) / upm.marketing_spend * 100::numeric
      else null::numeric
    end
  ) as average_roi_percentage
from
  dim_campaign_type dct
  join campaigns c on c.campaign_type_id = dct.id
  join unified_performance_metrics_v1 upm on upm.campaign_id = c.id
group by
  dct.id,
  dct.name,
  dct.slug,
  dct.icon,
  dct.color,
  dct.bg_gradient;

  create table public.dim_metric_type (
  id uuid not null default gen_random_uuid (),
  code text not null,
  description text not null,
  unit text null,
  category text not null,
  created_at timestamp with time zone null default now(),
  constraint dim_metric_type_pkey primary key (id),
  constraint dim_metric_type_code_key unique (code)
) TABLESPACE pg_default;

create index IF not exists idx_dim_metric_category on public.dim_metric_type using btree (category) TABLESPACE pg_default;

create table public.dim_campaign_type (
  id uuid not null default gen_random_uuid (),
  name character varying not null,
  slug character varying not null,
  description text null,
  icon text null,
  color text null,
  bg_gradient text null,
  primary_metric_type_id uuid not null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint dim_campaign_type_pkey primary key (id),
  constraint dim_campaign_type_slug_key unique (slug),
  constraint dim_campaign_type_primary_metric_type_fkey foreign KEY (primary_metric_type_id) references dim_metric_type (id)
) TABLESPACE pg_default;

create index IF not exists idx_dim_campaign_type_slug on public.dim_campaign_type using btree (slug) TABLESPACE pg_default;

create table public.brands (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  name character varying(255) not null,
  slug character varying(100) not null,
  description text null,
  logo_url text null,
  brand_colors jsonb null default '{}'::jsonb,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  primary_domain character varying(255) null,
  industry_id uuid null,
  currency_code character varying(3) null,
  currency_symbol character varying(5) null,
  constraint brands_pkey primary key (id),
  constraint brands_tenant_id_slug_key unique (tenant_id, slug),
  constraint brands_industry_id_fkey foreign KEY (industry_id) references industries (id),
  constraint brands_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_brands_tenant_id on public.brands using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_brands_slug on public.brands using btree (tenant_id, slug) TABLESPACE pg_default;

create index IF not exists idx_brands_is_active on public.brands using btree (tenant_id, is_active) TABLESPACE pg_default;