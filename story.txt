Tech Story Template: OKR Real-Time Dashboard
📌 Feature Name OKR Real-Time Dashboard for Growth Tracking
🎯 Introduction The OKR Dashboard provides comprehensive real-time visibility into Objectives and Key Results performance across all business units. It enables marketing teams, executives, and growth managers to monitor progress toward critical goals like growing TikTok followers from 15K to 100K, improving engagement rates, and tracking revenue metrics. The dashboard transforms raw performance data into actionable insights through interactive visualizations, health scoring, and automated alerts for at-risk objectives.
❗ Problem Statement `Marketing and growth teams currently struggle with fragmented OKR tracking across multiple platforms and manual reporting processes. Key pain points include:
Data Silos: Metrics scattered across TikTok, Instagram, Google Analytics, and internal systems
Manual Reporting: Weekly/monthly manual compilation of progress updates consuming 4-6 hours per week
Delayed Insights: Performance issues identified too late, missing critical intervention windows
Executive Visibility: Leadership lacks real-time visibility into progress toward strategic objectives
Resource Allocation: Teams can't quickly identify which OKRs need immediate attention or additional resources
Historical Context: No easy way to analyze trends and predict future performance based on current trajectory`
✅ Solution Overview `The OKR Dashboard creates a unified, real-time command center for all objective tracking. The solution automatically aggregates data from multiple sources, calculates progress percentages, assigns health scores, and provides predictive insights. Key architectural principles include:
Real-time Data Processing: Live updates from fact_metric_value table through optimized database views
Modular Component System: Reusable React components built with shadcn/ui for consistency and maintainability
Intelligent Automation: Automated health scoring, performance status calculations, and at-risk identification
Decision Support: Interactive filtering, trend analysis, and drill-down capabilities for actionable insights`
🛠️ Technical Architecture
1. Data Layer
Entity
Description
v_okr_current_performance
Core view providing real-time OKR metrics with calculated progress percentages and performance status
v_okr_progress_summary
Aggregated view showing OKR health scores, metric counts, and completion statistics
v_brand_okr_dashboard
Executive summary view with brand-level performance distribution and category breakdowns
v_okr_trend_analysis
Historical performance data for trend visualization and predictive analytics
fact_metric_value
Source table containing all metric measurements from various platforms (TikTok, Instagram, etc.)









Best Practice: Centralize filtering and complex logic using views or stored procedures for performance and security.
2. API Layer
Use @supabase/supabase-js for database connectivity and real-time subscriptions.
Fetch from views using .from('v_okr_current_performance').select(...) for optimized queries.
Implement service classes (OKRService) to abstract database operations.
Utilize TanStack Query for intelligent caching with 2-5 minute stale times based on data volatility.
Best Practice: Abstract API logic into service modules or reusable hooks for testability and separation of concerns.
2.1. OKRService (Supabase Queries)
Purpose: Handles all data interactions with the Supabase public views.
AC:
fetchCurrentPerformanceOKRs(brandId: string): Fetches data from public.v_okr_current_performance for a given brand_id, ordered by is_primary DESC, okr_category.
fetchProgressSummary(brandId: string): Fetches data from public.v_okr_progress_summary for a given brand_id, ordered by okr_health_score DESC.
fetchBrandDashboardOverview(brandId: string): Fetches data from public.v_brand_okr_dashboard for a given brand_id.
fetchOKRTrendAnalysis(okrId: string): Fetches data from public.v_okr_trend_analysis for a given okr_id, where is_primary = true, ordered by date DESC.
fetchAttentionMetrics(brandId: string): Fetches metrics needing attention from public.v_okr_current_performance where brand_id matches and performance_status is 'Behind' or 'At Risk', is_primary = true, ordered by progress_percentage ASC.
fetchAIInsights(brandId: string): Fetches insights from public.ai_insights related to the brand_id (and potentially okr_objective_id or metric_type_id if specific insights are needed).
// services/okrService.js
import { supabase } from '../lib/supabaseClient';

const BRAND_ID = '4743e593-3f09-4eba-96b4-c4c1413bca47'; // Use a constant or pass dynamically

export const OKRService = {
  // 1. Get all OKRs for FitLeasure brand with current performance
  fetchCurrentPerformanceOKRs: async (brandId = BRAND_ID) => {
    const { data, error } = await supabase
      .from('v_okr_current_performance')
      .select('*')
      .eq('brand_id', brandId)
      .order('is_primary', { ascending: false })
      .order('okr_category');
    if (error) throw error;
    return data;
  },

  // 2. Get OKR progress summary for executive review
  fetchProgressSummary: async (brandId = BRAND_ID) => {
    const { data, error } = await supabase
      .from('v_okr_progress_summary')
      .select('*')
      .eq('brand_id', brandId)
      .order('okr_health_score', { ascending: false });
    if (error) throw error;
    return data;
  },

  // 3. Get brand dashboard overview
  fetchBrandDashboardOverview: async (brandId = BRAND_ID) => {
    const { data, error } = await supabase
      .from('v_brand_okr_dashboard')
      .select('*')
      .eq('brand_id', brandId);
    if (error) throw error;
    return data;
  },

  // 4. Get trend analysis for specific OKR
  fetchOKRTrendAnalysis: async (okrId) => {
    const { data, error } = await supabase
      .from('v_okr_trend_analysis')
      .select('*')
      .eq('okr_id', okrId)
      .eq('is_primary', true)
      .order('date', { ascending: false });
    if (error) throw error;
    return data;
  },

  // 5. Get all metrics needing attention (behind or at risk)
  fetchAttentionMetrics: async (brandId = BRAND_ID) => {
    const { data, error } = await supabase
      .from('v_okr_current_performance')
      .select('objective_name, metric_name, current_value, metric_target_value, progress_percentage, performance_status, platform_name')
      .eq('brand_id', brandId)
      .in('performance_status', ['Behind', 'At Risk'])
      .eq('is_primary', true)
      .order('progress_percentage', { ascending: true });
    if (error) throw error;
    return data;
  },

  // Fetch AI Insights (from public.ai_insights table)
  fetchAIInsights: async (brandId = BRAND_ID) => {
    const { data, error } = await supabase
      .from('ai_insights')
      .select('*')
      .eq('brand_id', brandId); // Add more filters if specific OKR or metric insights are needed
    if (error) throw error;
    return data;
  },
};

2.2. useOKRData (React Query Hook)
Purpose: Manages data fetching, caching, and synchronization for OKRs using React Query.
AC:
A primary useOKRData(brandId: string) hook (or multiple specialized hooks like useCurrentPerformance(brandId), useProgressSummary(brandId), etc.) that wraps OKRService calls.
Utilizes React Query's useQuery to manage loading, error, and data states for each view.
Caches fetched data to prevent unnecessary re-fetches.
Automatically refetches data on stale queries (e.g., on window focus, or configurable intervals).
Ensures brandId is passed down to OKRService calls.
// hooks/useOKRData.js
import { useQuery } from '@tanstack/react-query';
import { OKRService } from '../services/okrService';

const STALE_TIME_MINUTES = 5 * 60 * 1000; // 5 minutes in milliseconds

export const useCurrentPerformanceOKRs = (brandId) => {
  return useQuery({
    queryKey: ['okrsCurrentPerformance', brandId],
    queryFn: () => OKRService.fetchCurrentPerformanceOKRs(brandId),
    staleTime: STALE_TIME_MINUTES,
    enabled: !!brandId, // Only run query if brandId is available
  });
};

export const useProgressSummary = (brandId) => {
  return useQuery({
    queryKey: ['okrProgressSummary', brandId],
    queryFn: () => OKRService.fetchProgressSummary(brandId),
    staleTime: STALE_TIME_MINUTES,
    enabled: !!brandId,
  });
};

export const useBrandDashboardOverview = (brandId) => {
  return useQuery({
    queryKey: ['brandDashboardOverview', brandId],
    queryFn: () => OKRService.fetchBrandDashboardOverview(brandId),
    staleTime: STALE_TIME_MINUTES,
    enabled: !!brandId,
  });
};

export const useOKRTrendAnalysis = (okrId) => {
  return useQuery({
    queryKey: ['okrTrendAnalysis', okrId],
    queryFn: () => OKRService.fetchOKRTrendAnalysis(okrId),
    staleTime: STALE_TIME_MINUTES,
    enabled: !!okrId, // Only run if okrId is available
  });
};

export const useAttentionMetrics = (brandId) => {
  return useQuery({
    queryKey: ['attentionMetrics', brandId],
    queryFn: () => OKRService.fetchAttentionMetrics(brandId),
    staleTime: STALE_TIME_MINUTES,
    enabled: !!brandId,
  });
};

export const useAIInsights = (brandId) => {
  return useQuery({
    queryKey: ['aiInsights', brandId],
    queryFn: () => OKRService.fetchAIInsights(brandId),
    staleTime: STALE_TIME_MINUTES,
    enabled: !!brandId,
  });
};

2.3. Zustand Store (Application State)
Purpose: Maintains global application state (e.g., active tab, filter selections).
AC:
Stores activeTab, filterCategory, filterStatus.
Provides actions to update these state variables.
Components subscribe to relevant parts of the store for UI updates.
Here's the updated technical implementation story for the Next.js developer, incorporating the specific Supabase view names and queries.

// store/appStore.js
import { create } from 'zustand';

export const useAppStore = create((set) => ({
  activeTab: 'Overview',
  filterCategory: 'All',
  filterStatus: 'All',
  setTab: (tab) => set({ activeTab: tab }),
  setFilterCategory: (category) => set({ filterCategory: category }),
  setFilterStatus: (status) => set({ filterStatus: status }),
}));
2.4. Progress and Health Calculations
These calculations will be done on the frontend using the data fetched from v_okr_current_performance. This function should be a pure utility.
// utils/okrCalculations.js
export const calculateOKRStatus = (okr) => {
  const { current_value, metric_target_value, time_progress_percent, performance_status: initialStatus } = okr;

  if (initialStatus === "Target Achieved" || initialStatus === "Completed") { // Assuming 'Completed' is equivalent to 'Target Achieved' in views
    return {
      progress_percentage: 100,
      status: "Target Achieved",
      health: "green" // Assuming green for achieved
    };
  }
  if (initialStatus === "Not Started") {
    return {
      progress_percentage: 0,
      status: "Not Started",
      health: "gray"
    };
  }

  const progress_percentage = metric_target_value !== 0 ? (current_value / metric_target_value) * 100 : 0;
  let status = initialStatus; // Default to status from DB view
  let health = "gray";

  // Refine health based on progress and time_progress_percent (if available)
  if (progress_percentage >= 80) { // High progress
    health = "green";
  } else if (progress_percentage >= 50 && progress_percentage < 80) { // Medium progress
    health = "yellow";
  } else { // Low progress
    health = "red";
  }

  // Override health based on performance_status from DB for "At Risk" or "Behind"
  if (initialStatus === "At Risk") health = "red";
  if (initialStatus === "Behind") health = "yellow";

  return {
    progress_percentage: parseFloat(progress_percentage.toFixed(2)),
    status,
    health
  };
};

OKR Dashboard: Technical Implementation Story V2 🚀
This story outlines the development of the FitLeasure.com OKR Dashboard in Next.js, leveraging React components, state management with Zustand, data fetching with React Query, and real-time data from specified Supabase views.

1. Core UI Components (Built with shadcn/ui principles)
Developer will create reusable UI components focusing on responsiveness and accessibility. The components detailed in the previous story (e.g., ProgressRing, OKRHealthBadge, OKRCard, MetricsTable, DashboardStats, OKRTrendChart) remain the same in their rendering responsibilities. Their data input will now come from the updated data layer.

2. Data Layer & Real-time Tracking
Developer will set up the data flow, ensuring real-time updates and efficient state management using the specified Supabase views.
2.1. OKRService (Supabase Queries)
Purpose: Handles all data interactions with the Supabase public views.
AC:
fetchCurrentPerformanceOKRs(brandId: string): Fetches data from public.v_okr_current_performance for a given brand_id, ordered by is_primary DESC, okr_category.
fetchProgressSummary(brandId: string): Fetches data from public.v_okr_progress_summary for a given brand_id, ordered by okr_health_score DESC.
fetchBrandDashboardOverview(brandId: string): Fetches data from public.v_brand_okr_dashboard for a given brand_id.
fetchOKRTrendAnalysis(okrId: string): Fetches data from public.v_okr_trend_analysis for a given okr_id, where is_primary = true, ordered by date DESC.
fetchAttentionMetrics(brandId: string): Fetches metrics needing attention from public.v_okr_current_performance where brand_id matches and performance_status is 'Behind' or 'At Risk', is_primary = true, ordered by progress_percentage ASC.
fetchAIInsights(brandId: string): Fetches insights from public.ai_insights related to the brand_id (and potentially okr_objective_id or metric_type_id if specific insights are needed).
TC:
Unit test each fetch method with valid and invalid brandId/okrId inputs to ensure correct data retrieval or error handling.
Verify the structure of the returned data matches the expected schema from each view.
Simulate Supabase connection issues and verify robust error logging/handling.
2.2. useOKRData (React Query Hook)
Purpose: Manages data fetching, caching, and synchronization for OKRs using React Query.
AC:
A primary useOKRData(brandId: string) hook (or multiple specialized hooks like useCurrentPerformance(brandId), useProgressSummary(brandId), etc.) that wraps OKRService calls.
Utilizes React Query's useQuery to manage loading, error, and data states for each view.
Caches fetched data to prevent unnecessary re-fetches.
Automatically refetches data on stale queries (e.g., on window focus, or configurable intervals).
Ensures brandId is passed down to OKRService calls.
TC:
Test loading state: Components depending on the hook display loading indicators.
Test success state: Data from respective Supabase views is correctly fetched and available to components.
Test error state: Hook provides error information, and components handle errors gracefully.
Verify caching behavior: Data should not be re-fetched immediately on re-render if cached.
Verify refetch on external changes (e.g., by manually invalidating queries).
2.3. Zustand Store (Application State)
Purpose: Maintains global application state (e.g., active tab, filter selections).
AC:
Stores activeTab, filterCategory, filterStatus.
Provides actions to update these state variables.
Components subscribe to relevant parts of the store for UI updates.
TC:
Test tab switching: Verify activeTab updates correctly.
Test filter changes: Verify filterCategory and filterStatus update.
Ensure components re-render correctly when store state changes.
2.4. Progress and Health Calculations
Purpose: Automatic calculation of progress and health status for each OKR.
AC:
The calculateOKRStatus helper function will continue to derive progress_percentage, status, and health based on the data retrieved from the Supabase views (specifically v_okr_current_performance).
The calculations for current_value / target_value * 100 for progress and the comparative logic for health will be applied to the data fetched.



3. Frontend Layer

3.1. Tab Navigation
Purpose: Allows users to switch between different dashboard views.
AC:
Tabs for "Overview", "OKRs", "Metrics", "Attention", "AI Insights".
Clicking a tab updates the activeTab state and displays the corresponding content, populated by data from the appropriate views.
4. AI Insights Section
Developer will implement the AI Insights display, fetching real insights from the ai_insights table.


3.2 🧩 Components:
Component
Purpose
OKRCard
Individual OKR display with circular progress ring, health badge, and metrics summary
MetricsTable
Comprehensive metrics overview with sortable columns and status filtering
DashboardStats
Executive overview showing performance distribution across categories and health scores
OKRTrendChart
Historical visualization using Recharts with line/area chart options and trend indicators
ProgressRing
Animated circular progress indicator with color-coded status (red/yellow/blue/green)
OKRHealthBadge
Color-coded health score display with contextual labels (Excellent/Good/At Risk)
OKRFilters
Interactive filtering interface for categories, status, and date ranges
OKRQuickActions



Action panel for creating OKRs, exporting reports, and accessing settings

1. Core UI Components (Built with shadcn/ui principles)
Developer will create reusable UI components focusing on responsiveness and accessibility.

1.1. ProgressRing (Component)
Purpose: Displays circular progress for an OKR's completion percentage.

AC:

Renders a circular progress bar based on progress prop (0-100%).

Changes color dynamically (e.g., red for <50%, yellow for 50-80%, green for >80%).

Displays the percentage value clearly in the center.

1.2. OKRHealthBadge (Component)
Purpose: Shows the health status of an OKR (Healthy, Warning, Critical, N/A).

AC:

Displays text (Healthy/Warning/Critical/N/A) with corresponding background color.

Colors: Green (Healthy), Yellow (Warning), Red (Critical), Gray (N/A).

TC:

Test health="green": Renders "Healthy" with green styling.

Test health="red": Renders "Critical" with red styling.

Test health="gray": Renders "N/A" with gray styling.

1.3. OKRCard (Component)
Purpose: Displays an individual OKR with key details and progress.

AC:

Shows objective_name, key_result_metric, target_value, current_value.

Integrates ProgressRing and OKRHealthBadge components.

Is clickable to view more details (placeholder for now).

TC:

Render with sample data, verify all fields are displayed correctly.

Verify ProgressRing and OKRHealthBadge display correct states based on OKR data.

1.4. MetricsTable (Component)
Purpose: Comprehensive tabular view of OKR metrics.

AC:

Displays OKRs in a sortable table with columns: Objective, Metric, Target, Current, Progress (%), Time Progress (%), Status, Health.

Status badges and health badges are correctly applied to rows.

Handles empty states gracefully.

TC:

Render with sample data, ensure all columns and rows populate.

Apply various filterStatus values (e.g., "At Risk", "Completed") and verify correct filtering.

Test empty data array for correct empty state message.

1.5. DashboardStats (Component)
Purpose: Executive overview of key performance distribution.

AC:

Displays count of total OKRs, and counts by status (Target Achieved, On Track, Behind, At Risk, Not Started).

Includes a simple chart (e.g., Recharts AreaChart) showing health distribution.

TC:

Verify counts match the provided processedOKRData.

Check chart renders and visually represents health distribution (e.g., more "green" bars/area if most OKRs are healthy).

1.6. OKRTrendChart (Component)
Purpose: Visualizes historical trends for key metrics.

AC:

Uses Recharts to display line/area charts.

Accepts trendData prop (mocked for now) to render trends for metrics like Romi, Conversion Rate, Revenue.

TC:

Render with mock trend data, verify lines are drawn for each metric.

Hover over chart to verify Tooltip functionality.

🔄 Custom Hooks:
Hook
Responsibility
useOKRData
Orchestrates data fetching for all OKR-related queries using TanStack Query with proper error handling
useOKRFilters
Manages filter state and URL synchronization for category, status, and search parameters
useOKRExport
Handles data export functionality with format options (PDF, Excel, CSV)

🧪 Acceptance Criteria (AC)
✅ AC1: Display of Core Data
User sees complete OKR overview on page load within 2 seconds
Dashboard displays 4 main tabs: Overview, OKRs, Metrics, Attention
All progress percentages calculated correctly from current_value/target_value
Health scores displayed with appropriate color coding (Green 80%+, Blue 60-79%, Yellow 40-59%, Red <40%)
Loading states show skeleton placeholders, error states display user-friendly messages
✅ AC2: Filtering
Category filter dropdown with options: Brand Awareness, Engagement, Growth, Retention, Revenue
Performance status filter: All, Target Achieved, On Track, Behind, At Risk
Search functionality filters OKRs by objective name (case-insensitive, partial match)
Multiple filters can be applied simultaneously
Filter state persists in URL for shareable links
✅ AC3: Data Visualizations
Progress rings animate smoothly from 0 to actual percentage on component mount
Trend charts display historical data with proper date formatting and value scaling
Health score badges show correct status labels and colors based on calculated scores
Performance distribution charts reflect accurate counts across all categories
Charts are responsive and maintain readability on mobile devices
✅ AC4: Drilldown / Detail View
Clicking OKR card opens detailed metrics view with individual key results
Metrics table shows complete metric information: current value, target, progress, last updated
Navigation breadcrumbs allow easy return to main dashboard
Detail view includes historical trend chart for selected OKR
Platform-specific breakdowns visible when applicable (TikTok, Instagram, etc.)
🧪 Suggested Unit Test Cases
Test ID
Scenario
Expected Outcome
TC01
ProgressRing component renders with 75% progress
Ring displays "75%" in center, uses blue stroke color, animation completes within 500ms
TC02
OKRHealthBadge with score of 85
Displays "Excellent (85%)" badge with green color and success variant
TC03
OKRCard with at-risk metrics > 0
Shows alert triangle icon, health badge reflects risk status, "View Details" button is enabled
TC04
MetricsTable sorting by progress percentage
Table rows reorder correctly, sort icon updates, maintains filter state
TC05
Dashboard tab navigation
Each tab loads appropriate components, URL updates, active state styling applied
TC06
Filter by "Behind" performance status
Table shows only metrics with progress < 80% of target, count updates in filter badge
TC07
useOKRData hook with invalid brand ID
Returns error state, triggers error boundary, loading state resolves to false
TC08
OKRTrendChart with line/area toggle
Chart type switches correctly, data points remain accurate, legend updates
TC09
Search OKRs by objective name "TikTok"
Filters results to show only OKRs containing "TikTok" (case-insensitive)
TC10
Mobile responsive design
Components stack vertically, touch targets meet minimum size, charts remain readable


fact metric:
create table public.fact_metric_value (
  date_id integer not null,
  platform_id uuid not null,
  metric_type_id uuid not null,
  value numeric not null,
  granularity text not null default 'daily'::text,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  brand_id uuid null default gen_random_uuid (),
  tenant_id uuid null default gen_random_uuid (),
  tags json null,
  constraint fact_metric_value_pkey primary key (date_id, platform_id, metric_type_id, granularity),
  constraint fact_metric_value_brand_id_fkey foreign KEY (brand_id) references brands (id),
  constraint fk_fact_platform foreign KEY (platform_id) references dim_platform (id),
  constraint fk_fact_date foreign KEY (date_id) references dim_date (id),
  constraint fk_fact_metric_type foreign KEY (metric_type_id) references dim_metric_type (id),
  constraint fact_metric_value_tenant_id_fkey foreign KEY (tenant_id) references tenants (id),
  constraint chk_value_non_negative check ((value >= (0)::numeric)),
  constraint chk_granularity check (
    (
      granularity = any (
        array['daily'::text, 'weekly'::text, 'monthly'::text]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_fact_date_platform on public.fact_metric_value using btree (date_id, platform_id) TABLESPACE pg_default;

create index IF not exists idx_fact_metric_type_value on public.fact_metric_value using btree (metric_type_id, value) TABLESPACE pg_default;

create index IF not exists idx_fact_platform_metric on public.fact_metric_value using btree (platform_id, metric_type_id) TABLESPACE pg_default;

create index IF not exists idx_fact_date_metric on public.fact_metric_value using btree (date_id, metric_type_id) TABLESPACE pg_default;

v_okr_current_performance:
create view public.v_okr_performance as
with
  latest_metrics as (
    select distinct
      on (fmv.platform_id, fmv.metric_type_id) fmv.platform_id,
      fmv.metric_type_id,
      fmv.value as current_value,
      fmv.date_id,
      dd.date as metric_date
    from
      fact_metric_value fmv
      join dim_date dd on fmv.date_id = dd.id
    where
      fmv.granularity = 'daily'::text
    order by
      fmv.platform_id,
      fmv.metric_type_id,
      dd.date desc
  ),
  monthly_aggregates as (
    select
      fmv.platform_id,
      fmv.metric_type_id,
      sum(fmv.value) as monthly_sum,
      avg(fmv.value) as monthly_avg,
      count(*) as days_tracked
    from
      fact_metric_value fmv
      join dim_date dd on fmv.date_id = dd.id
    where
      dd.month::numeric = EXTRACT(
        month
        from
          CURRENT_DATE
      )
      and dd.year::numeric = EXTRACT(
        year
        from
          CURRENT_DATE
      )
      and fmv.granularity = 'daily'::text
    group by
      fmv.platform_id,
      fmv.metric_type_id
  )
select
  o.id,
  o.tenant_id,
  o.brand_id,
  o.title,
  o.description,
  o.target_value,
  o.target_date_id,
  o.metric_type_id,
  o.platform_id,
  o.granularity,
  o.is_active,
  o.created_at,
  o.updated_at,
  COALESCE(lm.current_value, ma.monthly_avg, 0::numeric) as current_value,
  lm.metric_date as last_update_date,
  case
    when o.granularity = 'monthly'::text then case
      when o.target_value > 0::numeric then round(
        COALESCE(
          ma.monthly_sum,
          ma.monthly_avg * 30::numeric,
          0::numeric
        ) / o.target_value * 100::numeric,
        1
      )
      else 0::numeric
    end
    else case
      when o.target_value > 0::numeric then round(
        COALESCE(lm.current_value, 0::numeric) / o.target_value * 100::numeric,
        1
      )
      else 0::numeric
    end
  end as progress_percentage,
  case
    when COALESCE(lm.current_value, ma.monthly_avg, 0::numeric) = 0::numeric then 'No Data'::text
    when o.granularity = 'monthly'::text then case
      when (
        COALESCE(
          ma.monthly_sum,
          ma.monthly_avg * 30::numeric,
          0::numeric
        ) / NULLIF(o.target_value, 0::numeric)
      ) >= 0.9 then 'On Track'::text
      when (
        COALESCE(
          ma.monthly_sum,
          ma.monthly_avg * 30::numeric,
          0::numeric
        ) / NULLIF(o.target_value, 0::numeric)
      ) >= 0.7 then 'Behind'::text
      else 'At Risk'::text
    end
    else case
      when (
        lm.current_value / NULLIF(o.target_value, 0::numeric)
      ) >= 0.9 then 'On Track'::text
      when (
        lm.current_value / NULLIF(o.target_value, 0::numeric)
      ) >= 0.7 then 'Behind'::text
      else 'At Risk'::text
    end
  end as status,
  case
    when COALESCE(lm.current_value, ma.monthly_avg, 0::numeric) = 0::numeric then 'At Risk'::text
    when o.granularity = 'monthly'::text then case
      when (
        COALESCE(
          ma.monthly_sum,
          ma.monthly_avg * 30::numeric,
          0::numeric
        ) / NULLIF(o.target_value, 0::numeric)
      ) >= 0.8 then 'Good'::text
      else 'At Risk'::text
    end
    else case
      when (
        lm.current_value / NULLIF(o.target_value, 0::numeric)
      ) >= 0.8 then 'Good'::text
      else 'At Risk'::text
    end
  end as health,
  dp.display_name as platform_name,
  dp.category as platform_category,
  dmt.description as metric_description,
  dmt.unit as metric_unit,
  dmt.category as metric_category
from
  okr_objectives o
  left join latest_metrics lm on o.platform_id = lm.platform_id
  and o.metric_type_id = lm.metric_type_id
  left join monthly_aggregates ma on o.platform_id = ma.platform_id
  and o.metric_type_id = ma.metric_type_id
  left join dim_platform dp on o.platform_id = dp.id
  join dim_metric_type dmt on o.metric_type_id = dmt.id
where
  o.is_active = true;


dashboard complete?
create view public.v_okr_dashboard_complete as
select
  vop.id,
  vop.tenant_id,
  vop.title,
  vop.current_value,
  vop.target_value,
  vop.progress_percentage,
  vop.status,
  vop.health,
  vop.platform_name,
  vop.metric_unit,
  vop.metric_description,
  vdc.daily_change_percentage,
  vdc.daily_change_absolute,
  vdc.change_direction,
  case
    when vop.metric_unit = 'USD'::text then concat(
      '$',
      case
        when vop.current_value >= 1000000::numeric then round(vop.current_value / 1000000::numeric, 1) || 'M'::text
        when vop.current_value >= 1000::numeric then round(vop.current_value / 1000::numeric, 1) || 'K'::text
        else round(vop.current_value, 0)::text
      end
    )
    when vop.metric_unit = '%'::text then round(vop.current_value, 1) || '%'::text
    when vop.metric_unit = 'count'::text then round(vop.current_value, 0)::text
    else round(vop.current_value, 1)::text
  end as display_value,
  case
    when vdc.daily_change_percentage is not null then case vdc.change_direction
      when 'up'::text then concat('↑ ', abs(vdc.daily_change_percentage), '% daily')
      when 'down'::text then concat('↓ ', abs(vdc.daily_change_percentage), '% daily')
      else concat('→ ', abs(vdc.daily_change_percentage), '% daily')
    end
    else '-- % daily'::text
  end as change_display,
  case
    when vop.metric_description ~~* '%revenue%'::text then 'revenue'::text
    when vop.metric_description ~~* '%engagement%'::text then 'engagement'::text
    when vop.metric_description ~~* '%follower%'::text
    or vop.metric_description ~~* '%growth%'::text then 'growth'::text
    when vop.metric_description ~~* '%customer%'::text then 'customers'::text
    when vop.metric_description ~~* '%order%'::text
    or vop.metric_description ~~* '%purchase%'::text then 'orders'::text
    else 'general'::text
  end as metric_category_icon
from
  v_okr_performance vop
  left join v_okr_daily_changes vdc on vop.id = vdc.okr_id
order by
  (
    case vop.status
      when 'At Risk'::text then 1
      when 'Behind'::text then 2
      when 'On Track'::text then 3
      else 4
    end
  ),
  vop.progress_percentage;

OKR Management System - Technical Implementation Guide for Code Generation
1. System Architecture Overview
Purpose: Build an AI-powered OKR management platform that enables Brand Managers to create, customize, and manage Objectives and Key Results using intelligent suggestions based on brand context.

Tech Stack:

Frontend: Next.js 14+ (App Router), TypeScript, shadcn/ui, Tailwind CSS

Backend: Supabase (PostgreSQL, Auth, Real-time), Express.js (AI Suggestion Service)

State Management: React hooks, TanStack Query, Zustand (for brand store)

Type Safety: TypeScript with strict mode enabled

2. Data Flow Architecture
2.1 Primary Data Flow
User Access → Check Permissions (user_brand_roles via BrandStore)

Load Brand Context → Retrieve brand.industry_id from Supabase

Fetch Industries → Query industries table for dropdown

Load OKR Templates → Express.js API with brand context

Select & Customize → User modifies suggested OKRs

Create OKRs → Insert into okr_objectives via Supabase hooks

Track Origin → Store reference to okr_master.id

Manage & Monitor → CRUD operations on created OKRs

2.2 Advanced Flow Pattern


Rich Context Input → Express.js → Complex Database Queries → Contextual Suggestions
↓
Selected Suggestions → Customization Forms → Validation Layer
↓
Supabase Hooks → Database Transaction → Real-time Updates → UI Refresh
3. Database Schema Requirements
3.1 Master Data Tables (Reference)


-- Industries reference (for dropdown)
table public.industries (
  id uuid not null default gen_random_uuid (),
  name character varying(100) not null,
  slug character varying(50) not null,
  description text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint industries_pkey primary key (id),
  constraint industries_name_key unique (name),
  constraint industries_slug_key unique (slug)
) TABLESPACE pg_default;
index idx_industries_slug on public.industries using btree (slug) TABLESPACE pg_default;
-- OKR Master Templates (AI-suggested templates)
table public.okr_master (
  id uuid not null default gen_random_uuid (),
  industry character varying not null, -- String field for industry matching
  category character varying not null,
  objective_title character varying not null,
  objective_description text null,
  suggested_timeframe character varying null default 'quarterly'::character varying,
  priority_level integer null default 2,
  is_active boolean null default true,
  parent_okr_id uuid null,
  tags jsonb null default '[]'::jsonb,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint okr_master_pkey primary key (id),
  constraint okr_master_parent_fkey foreign KEY (parent_okr_id) references okr_master (id),
  constraint okr_master_priority_level_check check (
    (
      (priority_level >= 1)
      and (priority_level <= 3)
    )
  )
) TABLESPACE pg_default;
 index idx_okr_master_industry on public.okr_master using btree (industry) TABLESPACE pg_default;
 index idx_okr_master_category on public.okr_master using btree (category) TABLESPACE pg_default;
-- Template Metrics (linked to templates)
okr_master_metrics (
  id uuid PRIMARY KEY,
  okr_master_id uuid REFERENCES okr_master(id),
  metric_type_id uuid REFERENCES dim_metric_type(id),
  is_primary boolean DEFAULT false,
  target_improvement_percentage numeric,
  baseline_source varchar,
  weight numeric DEFAULT 1.0 CHECK (weight > 0 AND weight <= 1),
  created_at timestamptz DEFAULT now()
)
-- Dimension Tables
 table public.dim_platform (
  id uuid not null default gen_random_uuid (),
  name text not null,
  category text not null,
  display_name text not null,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  constraint dim_platform_pkey primary key (id),
  constraint dim_platform_name_key unique (name)
) TABLESPACE pg_default;
index  idx_dim_platform_category on public.dim_platform using btree (category) TABLESPACE pg_default;
 table public.dim_metric_type (
  id uuid not null default gen_random_uuid (),
  code text not null,
  description text not null,
  unit text null,
  category text not null,
  created_at timestamp with time zone null default now(),
  constraint dim_metric_type_pkey primary key (id),
  constraint dim_metric_type_code_key unique (code)
) TABLESPACE pg_default;
 index  idx_dim_metric_category on public.dim_metric_type using btree (category) TABLESPACE pg_default;
 table public.dim_date (
  id serial not null,
  date date not null,
  week_start date not null,
  month integer not null,
  quarter integer not null,
  year integer not null,
  is_business_day boolean not null default true,
  day_of_week integer not null,
  month_name character varying(20) not null,
  quarter_name character varying(10) not null,
  created_at timestamp with time zone null default now(),
  constraint dim_date_pkey primary key (id),
  constraint dim_date_date_key unique (date)
) TABLESPACE pg_default;
 index IF not exists idx_dim_date_week_start on public.dim_date using btree (week_start) TABLESPACE pg_default;
 index IF not exists idx_dim_date_month_year on public.dim_date using btree (year, month) TABLESPACE pg_default;
3.2 Transaction Tables


-- Main OKR storage (user-created OKRs)
create table public.okr_objectives (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  brand_id uuid not null,
  title character varying(255) not null,
  description text null,
  target_value numeric(15, 2) not null,
  target_date_id integer not null,
  metric_type_id uuid not null,
  platform_id uuid null,
  granularity text not null default 'daily'::text,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint okr_objectives_pkey primary key (id),
  constraint okr_objectives_metric_type_id_fkey foreign KEY (metric_type_id) references dim_metric_type (id),
  constraint okr_objectives_brand_id_fkey foreign KEY (brand_id) references brands (id),
  constraint okr_objectives_platform_id_fkey foreign KEY (platform_id) references dim_platform (id),
  constraint okr_objectives_target_date_id_fkey foreign KEY (target_date_id) references dim_date (id),
  constraint okr_objectives_tenant_id_fkey foreign KEY (tenant_id) references tenants (id),
  constraint okr_objectives_granularity_check check (
    (
      granularity = any (
        array['daily'::text, 'weekly'::text, 'monthly'::text]
      )
    )
  )
) TABLESPACE pg_default;
create index IF not exists idx_okr_objectives_tenant_brand on public.okr_objectives using btree (tenant_id, brand_id) TABLESPACE pg_default;
create index IF not exists idx_okr_objectives_target_date_id on public.okr_objectives using btree (target_date_id) TABLESPACE pg_default;
create index IF not exists idx_okr_objectives_metric_type on public.okr_objectives using btree (metric_type_id) TABLESPACE pg_default;
-- Existing brand table structure
create table public.brands (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  name character varying(255) not null,
  slug character varying(100) not null,
  description text null,
  logo_url text null,
  brand_colors jsonb null default '{}'::jsonb,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  primary_domain character varying(255) null,
  industry_id uuid null,
  constraint brands_pkey primary key (id),
  constraint brands_tenant_id_slug_key unique (tenant_id, slug),
  constraint brands_industry_id_fkey foreign KEY (industry_id) references industries (id),
  constraint brands_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
) TABLESPACE pg_default;
create index IF not exists idx_brands_tenant_id on public.brands using btree (tenant_id) TABLESPACE pg_default;
create index IF not exists idx_brands_slug on public.brands using btree (tenant_id, slug) TABLESPACE pg_default;
create index IF not exists idx_brands_is_active on public.brands using btree (tenant_id, is_active) TABLESPACE pg_default;
-- Tenant table (multi-tenancy)
create table public.tenants (
  id uuid not null default extensions.uuid_generate_v4 (),
  name character varying(255) not null,
  slug character varying(100) not null,
  description text null,
  settings jsonb null default '{}'::jsonb,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint tenants_pkey primary key (id),
  constraint tenants_slug_key unique (slug)
) TABLESPACE pg_default;
create index IF not exists idx_tenants_slug on public.tenants using btree (slug) TABLESPACE pg_default;
4. Component Architecture & Hierarchy
4.1 Page Structure


apps/web/app/workspace/okr/
├── dashboard/          # Performance Dashboard (move exitig apps\web\app\workspace\okr-dashboard\page.tsx)
│   └── page.tsx
├── create/            # OKR Creation Flow
│   └── page.tsx
├── manage/            # OKR Management
│   └── page.tsx
└── [id]/
    └── edit/          # Edit Individual OKR
        └── page.tsx
4.2 View Components (Client-Side)


apps/web/views/okr/
├── OKRCreationView.tsx       # Main creation flow orchestrator
├── OKRManagementView.tsx     # Management dashboard
├── OKREditView.tsx           # Individual OKR editing
└── OKRAnalyticsView.tsx      # Progress tracking & analytics
4.3 Component Hierarchy - Creation Flow


CreateOKRPage (Server Component)
└── OKRCreationView (Client Component)
    ├── BrandContextPanel
    │   ├── IndustrySelector (shadcn Select)
    │   ├── BrandInfoDisplay
    │   └── ContextEnrichmentForm (optional fields)
    ├── OKRTemplateGrid
    │   ├── TemplateCard (shadcn Card with Checkbox)
    │   ├── BulkActions (SelectAll, SelectedCount)
    │   └── EmptyState
    ├── OKRCustomizationPanel
    │   ├── SelectedOKRsList
    │   │   └── CustomizationForm (per OKR)
    │   └── GlobalSettings
    └── ActionButtons (Save, SaveAndCreateMore, Cancel)
4.4 Component Hierarchy - Management Flow


ManageOKRPage (Server Component)
└── OKRManagementView (Client Component)
    ├── FilterToolbar
    ├── BulkActionsToolbar
    ├── OKRDataTable (shadcn DataTable)
    └── MobileView (responsive cards)
5. Reusable UI Components Library


packages/ui/components/okr/
├── forms/
│   ├── BrandContextForm.tsx
│   ├── OKRCustomizationForm.tsx
│   └── QuickEditForm.tsx
├── display/
│   ├── OKRProgressCard.tsx
│   ├── TemplateCard.tsx
│   └── MetricBadge.tsx
├── selectors/
│   ├── MetricsSelector.tsx
│   ├── PlatformMultiSelect.tsx
│   ├── IndustrySelector.tsx
│   └── GranularityToggle.tsx
└── tables/
    ├── OKRManagementTable.tsx
    └── BulkActionsToolbar.tsx
6. Custom Hooks Architecture


packages/hooks/src/okr/
├── api/
│   ├── use-okr-suggestions.ts    # Express.js API integration
│   ├── use-okr-crud.ts           # Supabase CRUD operations
│   ├── use-brand-context.ts      # Brand data fetching
│   └── use-dimensions.ts         # Reference data loading
├── business/
│   ├── use-okr-validation.ts     # Form validation logic
│   └── use-bulk-operations.ts    # Bulk action handling
└── state/
    ├── use-okr-selection.ts      # Selection state
    └── use-customization-state.ts # Temporary state
7. API Specifications
7.1 Express.js Suggestion Service


// Endpoint: POST /api/okr-suggestions
interface OKRSuggestionRequest {
  // Required fields
  industry: string;           // From brands.industry_id
  brandName: string;
  tenantId: string;          // Multi-tenancy support
  // Optional enrichment
  keyProduct?: string;
  productCategory?: string;
  keyCompetition?: string[];
  majorKeywords?: string[];
  objective?: string;
  historicalOKRs?: string[];
}
interface OKRSuggestionResponse {
  suggestions: OKRTemplate[];
  metadata: {
    industry: string;
    brandContext: string;
    generatedAt: string;
    confidence: number;
  };
}
interface OKRTemplate {
  id: string;
  okrMasterId: string;      // Reference to okr_master.id
  title: string;
  description: string;
  category: string;
  priority: number;          // 1-3 scale
  suggestedTargetValue: number;
  suggestedTimeframe: 'daily' | 'weekly' | 'monthly' | 'quarterly';
  applicablePlatforms: string[];
  metricTypeId: string;     // Reference to dim_metric_type.id
  confidenceScore: number;
  reasoning?: string;
}
7.2 Supabase Hooks Specifications


// Create OKR Hook
interface CreateOKRInput {
  tenantId: string;
  brandId: string;
  objectives: Array<{
    title: string;
    description: string;
    targetValue: number;
    targetDateId: number;     // Reference to dim_date.id
    priority: number;
    granularity: 'daily' | 'weekly' | 'monthly';
    metricTypeId: string;
    platformId?: string;
    okrMasterId?: string;
  }>;
}
// Update OKR Hook  
interface UpdateOKRInput {
  id: string;
  updates: Partial<{
    title: string;
    targetValue: number;
    targetDateId: number;
    isActive: boolean;
    priority: number;
    platformId: string;
  }>;
}
// Bulk Operations Hook
interface BulkOperationInput {
  ids: string[];
  operation: 'archive' | 'activate' | 'deactivate';
  updates?: Partial<UpdateOKRInput['updates']>;
}
8. State Management Architecture
8.1 Brand Store (Zustand)


interface BrandStore {
  // State
  currentBrand: Brand | null;
  currentTenant: Tenant | null;
  industry: Industry | null;
  permissions: UserPermissions;
  // Actions
  loadBrandContext: () => Promise<void>;
  switchBrand: (brandId: string) => Promise<void>;
  refreshPermissions: () => Promise<void>;
}
8.2 OKR Creation State


interface OKRCreationState {
  // Selection state
  selectedTemplates: Map<string, OKRTemplate>;
  customizations: Map<string, CustomizationData>;
  // UI state
  isLoading: boolean;
  isSaving: boolean;
  errors: ValidationError[];
  // Actions
  selectTemplate: (template: OKRTemplate) => void;
  deselectTemplate: (templateId: string) => void;
  updateCustomization: (templateId: string, data: Partial<CustomizationData>) => void;
  saveOKRs: () => Promise<void>;
  reset: () => void;
}
9. Validation & Business Rules
9.1 Creation Validation Rules


const okrCreationSchema = z.object({
  title: z.string().min(3).max(200),
  targetValue: z.number().positive(),
  targetDateId: z.number().positive(),
  granularity: z.enum(['daily', 'weekly', 'monthly']),
  platformId: z.string().uuid().optional(),
  metricTypeId: z.string().uuid(),
  priority: z.number().int().min(1).max(10)
});
9.2 Business Logic Rules
Priority Levels: 1-3 scale (1=High, 2=Medium, 3=Low)

Date Validation: Target date must be future, reference dim_date table

Platform Compatibility: Validate metric types against platforms

Duplicate Prevention: Check for similar active OKRs

Multi-tenancy: All operations scoped to tenant_id

Bulk Limits: Maximum 50 OKRs per bulk operation

10. Responsive Design Specifications
10.1 Breakpoint Strategy


/* Mobile First Approach */
- Base: < 640px (Mobile)
- sm: 640px+ (Large Mobile)
- md: 768px+ (Tablet)
- lg: 1024px+ (Desktop)
- xl: 1280px+ (Wide Desktop)
- 2xl: 1536px+ (Ultra Wide)
10.2 Layout Patterns
Desktop (lg+): 3-column layout with full data table

Tablet (md): 2-column layout with condensed table

Mobile (base): Single column stack with cards

11. Performance Optimization Requirements
11.1 Frontend Optimizations


// Query Optimization
- React Query: 5-minute cache, stale-while-revalidate
- Optimistic updates for all mutations
- Virtual scrolling for lists > 100 items
// Code Splitting
- Lazy load: Analytics, BulkOperations, AdvancedFilters
- Route-based code splitting
// State Management
- Debounced search (300ms)
- Throttled scroll handlers (100ms)
11.2 Database Optimizations
Index on (tenant_id, brand_id) for all tables

Index on (industry) for okr_master

Composite index on (tenant_id, is_active) for okr_objectives

12. Error Handling & User Feedback
12.1 Error States
Network errors: Retry with exponential backoff

Validation errors: Inline field-level messages

Permission errors: Clear messaging with action suggestions

Server errors: Fallback UI with error boundaries

12.2 Loading States
Skeleton screens for initial loads

Progress indicators for long operations

Optimistic UI updates with rollback

13. Testing Requirements
Unit tests for all hooks

Component testing with React Testing Library

Integration tests for complete flows

E2E tests for critical paths

14. Critical Implementation Notes
Multi-tenancy Considerations
All queries must include tenant_id filter

Row-level security policies on all tables

Tenant isolation for all operations

Data Relationships
okr_objectives.target_date_id → dim_date.id (not direct date)

okr_objectives.metric_type_id → dim_metric_type.id

okr_objectives.platform_id → dim_platform.id (optional)

okr_objectives.okr_master_id → okr_master.id (for tracking origin)

Navigation Structure


const okrNavigation = [
  { label: 'Dashboard', href: '/workspace/okr/dashboard' },
  { label: 'Create OKRs', href: '/workspace/okr/create' },
  { label: 'Manage OKRs', href: '/workspace/okr/manage' }
]
15. Code Generation Guidelines
When generating code:

Type Safety First: Define all TypeScript interfaces before implementation

Component Composition: Build small, reusable components

Hook Patterns: Separate concerns (data, UI state, business logic)

Error Handling: Comprehensive try-catch with user-friendly messages

Performance: Memoization, lazy loading, optimistic updates

Multi-tenancy: Always include tenant_id in queries and mutations

Data References: Use foreign key relationships correctly (e.g., target_date_id not target_date)


industries table:
create table public.industries (
  id uuid not null default gen_random_uuid (),
  name character varying(100) not null,
  slug character varying(50) not null,
  description text null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint industries_pkey primary key (id),
  constraint industries_name_key unique (name),
  constraint industries_slug_key unique (slug)
) TABLESPACE pg_default;

create index IF not exists idx_industries_slug on public.industries using btree (slug) TABLESPACE pg_default;

okr_master: 
create table public.okr_master (
  id uuid not null default gen_random_uuid (),
  industry character varying not null,
  category character varying not null,
  objective_title character varying not null,
  objective_description text null,
  suggested_timeframe character varying null default 'quarterly'::character varying,
  priority_level integer null default 2,
  is_active boolean null default true,
  parent_okr_id uuid null,
  tags jsonb null default '[]'::jsonb,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint okr_master_pkey primary key (id),
  constraint okr_master_parent_fkey foreign KEY (parent_okr_id) references okr_master (id),
  constraint okr_master_priority_level_check check (
    (
      (priority_level >= 1)
      and (priority_level <= 3)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_okr_master_industry on public.okr_master using btree (industry) TABLESPACE pg_default;

create index IF not exists idx_okr_master_category on public.okr_master using btree (category) TABLESPACE pg_default;

okr_master_metrics:
create table public.okr_master_metrics (
  id uuid not null default gen_random_uuid (),
  okr_master_id uuid not null,
  metric_type_id uuid not null,
  is_primary boolean null default false,
  target_improvement_percentage numeric null,
  baseline_source character varying null,
  weight numeric null default 1.0,
  created_at timestamp with time zone null default now(),
  constraint okr_master_metrics_pkey primary key (id),
  constraint unique_okr_metric unique (okr_master_id, metric_type_id),
  constraint okr_master_metrics_metric_fkey foreign KEY (metric_type_id) references dim_metric_type (id),
  constraint okr_master_metrics_okr_fkey foreign KEY (okr_master_id) references okr_master (id),
  constraint okr_master_metrics_weight_check check (
    (
      (weight > (0)::numeric)
      and (weight <= (1)::numeric)
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_okr_master_metrics_okr on public.okr_master_metrics using btree (okr_master_id) TABLESPACE pg_default;

dim_platform:
create table public.dim_platform (
  id uuid not null default gen_random_uuid (),
  name text not null,
  category text not null,
  display_name text not null,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  constraint dim_platform_pkey primary key (id),
  constraint dim_platform_name_key unique (name)
) TABLESPACE pg_default;

create index IF not exists idx_dim_platform_category on public.dim_platform using btree (category) TABLESPACE pg_default;

 dim_metric_type:
 create table public.dim_metric_type (
  id uuid not null default gen_random_uuid (),
  code text not null,
  description text not null,
  unit text null,
  category text not null,
  created_at timestamp with time zone null default now(),
  constraint dim_metric_type_pkey primary key (id),
  constraint dim_metric_type_code_key unique (code)
) TABLESPACE pg_default;

create index IF not exists idx_dim_metric_category on public.dim_metric_type using btree (category) TABLESPACE pg_default;

dim_date:
create table public.dim_date (
  id serial not null,
  date date not null,
  week_start date not null,
  month integer not null,
  quarter integer not null,
  year integer not null,
  is_business_day boolean not null default true,
  day_of_week integer not null,
  month_name character varying(20) not null,
  quarter_name character varying(10) not null,
  created_at timestamp with time zone null default now(),
  constraint dim_date_pkey primary key (id),
  constraint dim_date_date_key unique (date)
) TABLESPACE pg_default;

create index IF not exists idx_dim_date_week_start on public.dim_date using btree (week_start) TABLESPACE pg_default;

create index IF not exists idx_dim_date_month_year on public.dim_date using btree (year, month) TABLESPACE pg_default;

okr_objectives :
create table public.okr_objectives (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  brand_id uuid not null,
  title character varying(255) not null,
  description text null,
  target_value numeric(15, 2) not null,
  target_date_id integer not null,
  metric_type_id uuid not null,
  platform_id uuid null,
  granularity text not null default 'daily'::text,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  master_template_id uuid null,
  constraint okr_objectives_pkey primary key (id),
  constraint okr_objectives_master_template_id_fkey foreign KEY (master_template_id) references okr_master (id),
  constraint okr_objectives_metric_type_id_fkey foreign KEY (metric_type_id) references dim_metric_type (id),
  constraint okr_objectives_tenant_id_fkey foreign KEY (tenant_id) references tenants (id),
  constraint okr_objectives_brand_id_fkey foreign KEY (brand_id) references brands (id),
  constraint okr_objectives_platform_id_fkey foreign KEY (platform_id) references dim_platform (id),
  constraint okr_objectives_target_date_id_fkey foreign KEY (target_date_id) references dim_date (id),
  constraint okr_objectives_granularity_check check (
    (
      granularity = any (
        array['daily'::text, 'weekly'::text, 'monthly'::text]
      )
    )
  )
) TABLESPACE pg_default;

create index IF not exists idx_okr_objectives_tenant_brand on public.okr_objectives using btree (tenant_id, brand_id) TABLESPACE pg_default;

create index IF not exists idx_okr_objectives_target_date_id on public.okr_objectives using btree (target_date_id) TABLESPACE pg_default;

create index IF not exists idx_okr_objectives_metric_type on public.okr_objectives using btree (metric_type_id) TABLESPACE pg_default;

create index IF not exists idx_okr_objectives_master_template on public.okr_objectives using btree (master_template_id) TABLESPACE pg_default;

brands:
create table public.brands (
  id uuid not null default gen_random_uuid (),
  tenant_id uuid not null,
  name character varying(255) not null,
  slug character varying(100) not null,
  description text null,
  logo_url text null,
  brand_colors jsonb null default '{}'::jsonb,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  primary_domain character varying(255) null,
  industry_id uuid null,
  constraint brands_pkey primary key (id),
  constraint brands_tenant_id_slug_key unique (tenant_id, slug),
  constraint brands_industry_id_fkey foreign KEY (industry_id) references industries (id),
  constraint brands_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_brands_tenant_id on public.brands using btree (tenant_id) TABLESPACE pg_default;

create index IF not exists idx_brands_slug on public.brands using btree (tenant_id, slug) TABLESPACE pg_default;

create index IF not exists idx_brands_is_active on public.brands using btree (tenant_id, is_active) TABLESPACE pg_default;

tenants:
create table public.tenants (
  id uuid not null default extensions.uuid_generate_v4 (),
  name character varying(255) not null,
  slug character varying(100) not null,
  description text null,
  settings jsonb null default '{}'::jsonb,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint tenants_pkey primary key (id),
  constraint tenants_slug_key unique (slug)
) TABLESPACE pg_default;

create index IF not exists idx_tenants_slug on public.tenants using btree (slug) TABLESPACE pg_default;


user_brand_roles:
create table public.user_brand_roles (
  id uuid not null default extensions.uuid_generate_v4 (),
  user_id uuid not null,
  brand_id uuid not null,
  tenant_id uuid not null,
  role character varying(50) not null default 'contributor'::character varying,
  permissions jsonb null default '{}'::jsonb,
  is_active boolean null default true,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint user_brand_roles_pkey primary key (id),
  constraint user_brand_roles_user_id_brand_id_key unique (user_id, brand_id),
  constraint user_brand_roles_brand_id_fkey foreign KEY (brand_id) references brands (id) on delete CASCADE,
  constraint user_brand_roles_tenant_id_fkey foreign KEY (tenant_id) references tenants (id) on delete CASCADE,
  constraint user_brand_roles_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_user_brand_roles_user_id on public.user_brand_roles using btree (user_id) TABLESPACE pg_default;

create index IF not exists idx_user_brand_roles_brand_id on public.user_brand_roles using btree (brand_id) TABLESPACE pg_default;

create trigger update_user_brand_roles_updated_at BEFORE
update on user_brand_roles for EACH row
execute FUNCTION update_updated_at_column ();